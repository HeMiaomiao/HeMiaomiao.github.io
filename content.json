{"meta":{"title":"Miaomiao's Blog","subtitle":"","description":"��ӭ�����ҵĲ���","author":"Miaomiao","url":"https://hemiaomiao.github.io","root":"/"},"pages":[{"title":"about","date":"2020-01-10T14:14:36.000Z","updated":"2021-09-17T14:46:58.000Z","comments":false,"path":"about/index.html","permalink":"https://hemiaomiao.github.io/about/index.html","excerpt":"","text":"[さくら荘のmiaomiao] 与&nbsp; miaomiao&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"tags","date":"2020-01-12T14:14:16.000Z","updated":"2021-01-13T11:11:40.000Z","comments":true,"path":"tags/index.html","permalink":"https://hemiaomiao.github.io/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2020-01-10T15:11:06.000Z","updated":"2021-09-17T14:44:16.000Z","comments":true,"path":"links/index.html","permalink":"https://hemiaomiao.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"读论文的方法","slug":"读论文的方法","date":"2022-03-12T07:57:28.000Z","updated":"2022-03-12T08:06:47.037Z","comments":true,"path":"2022/03/12/读论文的方法/","link":"","permalink":"https://hemiaomiao.github.io/2022/03/12/%E8%AF%BB%E8%AE%BA%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"怎么找论文 怎么读论文 速读的方法：","categories":[{"name":"科研","slug":"科研","permalink":"https://hemiaomiao.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://hemiaomiao.github.io/tags/%E8%AE%BA%E6%96%87/"}],"author":"Miaomiao"},{"title":"Robust KPI Anomaly Detection for Large-Scale Software Services with Partial Labels","slug":"Robust KPI Anomaly Detection for Large-Scale Software Services with Partial Labels","date":"2022-03-08T11:59:38.000Z","updated":"2022-03-12T08:25:42.701Z","comments":true,"path":"2022/03/08/Robust KPI Anomaly Detection for Large-Scale Software Services with Partial Labels/","link":"","permalink":"https://hemiaomiao.github.io/2022/03/08/Robust%20KPI%20Anomaly%20Detection%20for%20Large-Scale%20Software%20Services%20with%20Partial%20Labels/","excerpt":"","text":"","categories":[{"name":"科研","slug":"科研","permalink":"https://hemiaomiao.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://hemiaomiao.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"KPI异常检测","slug":"KPI异常检测","permalink":"https://hemiaomiao.github.io/tags/KPI%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"}],"author":"Miaomiao"},{"title":"Robust and Rapid Clustering of KPIs for Large-Scale Anomaly Detection","slug":"Robust and Rapid Clustering of KPIs for Large-Scale Anomaly Detection","date":"2022-03-08T11:59:12.000Z","updated":"2022-03-12T08:25:05.831Z","comments":true,"path":"2022/03/08/Robust and Rapid Clustering of KPIs for Large-Scale Anomaly Detection/","link":"","permalink":"https://hemiaomiao.github.io/2022/03/08/Robust%20and%20Rapid%20Clustering%20of%20KPIs%20for%20Large-Scale%20Anomaly%20Detection/","excerpt":"","text":"一.标题Robust and Rapid Clustering of KPIs for Large-Scale Anomaly 用于大规模异常检测的鲁棒快速KPI聚类 二.时间2018年 三.作者Zhihan Li, Y oujian Zhao, Rong Liu, Dan Pei 四.文章来源会议：2018 IEEE/ACM 26th International Symposium on Quality of Service (IWQoS) 五.关键字六.摘要—作者想要解决的问题由于模型选择、参数调整、模型训练或标记的巨大开销，对数以百万计的KPI进行大规模异常检测非常具有挑战性，在论文里面认为KPI聚类是由帮助的：我们可以将数以百万计的KPI聚集到一小部分集群中，然后在每个集群的基础上选择和训练模型。但是，KPI聚类面临着经典时间序列聚类里面没有出现的新挑战，KPI通常比其他时间序列长得多，噪声、异常、相移和振幅差异往往会改变KPI的形状，并且误导聚类算法。 七.摘要—作者提出的模型作者提出了一种健壮的并且快速的KPI聚类算法ROCKA，它包括四个步骤：预处理、基线提取、聚类和分配。这些技术有助于根据关键绩效指标的基本形状对其进行高精度和高效率的分组 八.摘要—模型的实验结果ROCKA的F-score高于0.85，并将最先进的异常检测算法的模型训练时间减少了90%，而性能损失仅为15% 九.引言—研究背景基于互联网的服务公司（如在线购物、社交网络、搜索引擎）监控其应用程序和系统的数千到数百万KPI（关键性能指标，如CPU利用率或每秒查询次数），以保持其服务的可靠性。KPI异常（如尖峰或低谷）通常表明相关应用程序可能出现故障，如服务器故障、网络过载、外部攻击等。因此，异常检测技术已被广泛用于及时检测异常事件，以最大限度地减少此类事件造成的损失。 十.引言—研究现状大多数异常检测算法（例如Opprentice、EDAG、DONUT）都假设每个KPI都需要一个单独的模型。因此，由于模型选择、参数调整、模型训练或异常标记的巨大开销，在数千到数百万个KPI上进行大规模异常检测非常具有挑战性。实际上，许多KPI是相似的，因为它们隐含的关联和相似性。如果我们能够根据相似性识别同种类的KPI(例如，负载均衡的服务器集群中每台服务器的查询数量)，并且把它们分组到一些集群中，可能每个集群只需要一个异常检测模型，因此明显地减少前面提及的各种开销。KPI是按预定义的时间间隔聚合的流数据（例如，1分钟或10秒），因此，它们本质上是时间序列。时间序列聚类作为数据挖掘中的一个热门话题，已经研究了20多年。大多数已发表的论文都集中在基于理想地时间序列数据的聚类方法和相似性度量上。这些理想化的时间序列通常是低维的（通常少于1000个数据点），这些理想化的时间序列通常是低维的（通常少于1000个数据点），曲线平滑，没有异常模式。 然而，KPI聚类面临着经典时间序列聚类中不存在的两个新挑战。 噪声、异常、相移和振幅差异通常会改变KPI的形状。(KPI上常见的四种形状变化，这些KPI的基本形状相似，因此可以被聚类到相同的集群中)这些在时间序列曲线上的形状变化（例如，大的或小的尖峰）通常会扭曲KPI的相似性，从而难以使用传统方法对KPI进行准确聚类。 KPI通常包含数万个数据点，因为为了完全捕获KPI的模式（例如周期性、季节性）数据会跨度几天到几周。但是，文献中很少有关于对具有异常和噪声的高维时间序列数据进行聚类的工作。 十一.引言—作者的创新点本文提出了一种健壮的和快速的时间序列聚类算法ROCKA，该算法能够以高精度和快速的速度对大规模真实世界的kpi进行聚类。为了进行有意义的比较，首先把KPI标准化从而消除振幅的差异。然后ROCKA提取每个KPI的基本形状，称为基线，从而进一步减少噪音和异常的影响。ROCKA采用基于形状的距离（SBD)作为距离度量，在处理高维时间序列数据的时候，它对相移是健壮的，并且实现了高的计算效率。然后ROCKA使用一种高效的基于密度的算法，从而根据基线的形状的相似性创建聚类。最后，一个具有代表性的KPI被标识为每个聚类的质心，并且新的KPI能够根据它们到质心的距离被分配。 本文的贡献总结如下： 这是第一个专注于对时间序列数据的特殊类型KPI进行聚类的工作，ROCKA是第一个被报道的对长时间序列进行健壮的和快速聚类的算法。 在ROCKA算法里面采用了三种有效的技术：基线提取、基于形状的相似性度量、基于密度的聚类方法。三个技术结合起来用于获取KPI的基本形状从而用于聚类和减少各种形状变化的影响。 使用公共时间序列数据集和真实世界的KPI数据集来验证ROCKA的健壮性和效率。在所有这些数据集上，它都超越了最先进的聚类算法YADING，并且对于真实世界的KPI，它的F分数高于0.85。 ROCKA把最先进的异常检测算法的模型训练时间减少了90%，同时性能损失仅仅15%。这是首次报道的使用聚类来减少异常检测的训练开销的研究。 十二.相关概念介绍1.存在的挑战KPI通常是周期性的，其周期可能从几天到几周不等，具体取决于应用程序和系统。因此，每个KPI通常有数千个点来完全捕获其在周期内的行为。真实世界的KPI和理想的时间序列相比有一些明显的形状变化： 噪音和异常：噪音和异常在KPI中非常常见。噪声通常指的是在KPI中期望值周围小的随机波动，异常是明显的波动，通常大于2个标准差。噪声和异常可能会误导聚类方法，因为它们会扭曲KPI之间的相似性。 振幅差异：KPI能是不同的规模。例如，在相同服务的两个密切相关但是不同的模型上的QPS可能看起来像下图的左侧，但如果我们去除振幅差异（如下图的右侧所示），这些KPI有相似的模式，可以作为一组进行分析。 相移：相移指的是两个KPI之间的全局水平移动。 它是非常普遍的发现KPI有显式或隐式的关联变化。例如，在相同系统的调用链上的一组有时间落后的KPI可能具有相似的形状，相移会导致找到相似的KPI变得困难。 这些变化为聚类KPI带来了重大挑战，因为它们可能会改变KPI的形状，聚类算法需要对这些变化是健壮的。以前的聚类算法通常直接根据原始数据计算相似性，因此不能对真实世界的KPI检测相干的集群。除此之外，KPI通常是高维的时间序列数据。算法在KPI长度方面应该具有低的复杂度。 2.模型ROCKA的概述在本文中，我们通过根据KPI基本形状的相似性进行聚类来应对这些挑战，不管噪音、异常、振幅差异和相移。这种聚类在KPI分析和大规模异常检测中非常有用。通过聚类，运维人员能够分析KPI的每个集群，并且为每个集群创建异常检测模型，从而显著降低模型成本并提高效率。 ROCKA由四个步骤组成：预处理、基线提取、聚类、分配。预处理是对原始KPI数据进行操作从而消除振幅差异和标准化数据。在基线提取步骤中，我们减少噪声，去除极值（可能是异常的值），并且提取KPI的基本形状（称为基线）。然后对采样KPI的基线进行聚类，具有抗相移和噪声的健壮性。最后，我们计算每个集群的质心，然后根据到这些质心的距离分配未被标记的KPI。为了对大量的KPI进行聚类，为了效率，使用随机采样的KPI的子集创建了一个聚类模型。然后把剩余的KPI分配给结果集群。即使KPI的数量非常大，一个小样本数据集也足够进行聚类。例如对于一个超过9000个时间序列的数据集，2000个样本就足够进行聚类。 十三.作者提出的模型的设计1.预处理KPI数据普遍有缺失值，但是缺失值的比例通常很小。 填充缺失值：根据缺失值相邻的数据点使用线性插值的方式填充缺失值，这样能够计算出两个KPI之间的逐点距离。 标准化：标准化能去除振幅的差异，并且帮助计算KPI之间的相似性 2.基线提取我们需要一种简单但有效的方法来去除那些可能是异常的极值，这样就可以提取一个粗略的基线来表示KPI的底层结构 平滑的极值：异常和平均值的偏差最大，一般在时间序列里面异常点的比例少于5%，所以可以删除和平均值偏差最大的前5%的数据，然后使用线性插值的方式进行填充，这样极值被移除，并且极值被相邻的正常观测值代替 提取基线：需要提取一个粗略的基线来代表每个KPI，一般来说KPI曲线是带着很多随机噪声的平滑曲线。第一步：使用小滑动窗口的移动平均值，这样把KPI曲线分成基线和残差两个部分。把原始数据Xt在基线的相对应的点记作 Xt* ，Xt* 是向量(Xt-w+1, · · · , Xt)的均值，Xt和Xt*之间的差值就是残差 提取的基线去除了大部分噪声和异常，同时保留了基本的形状，残差里面有随机噪声，在聚类里面不考虑。第二步：再次使用标准化得到标准的基线，从而在聚类算法里使用 3.基于密度的聚类根据采样的KPI它的基线的形状相似度使用基于密度的聚类算法。 (1) 基于形状的相似性度量（回顾）： 基于相关性的度量，例如互相关被使用作为相似性度量，它能够处理时间序列的相移，互相关使用卷积理论和快速傅里叶变换把计算复杂度降为O(mlog(m))，所以基于相关性的度量对于KPI是合适的相关性度量。互相关计算两个时间序列的滑动内积，对于相移具有健壮性。有文献在互相关的基础上提出了SBD(shape-based distance)，在理想的时间序列中使用它。本篇论文使用SBD来度量基线的相似性，基线比理想的时间序列有更高维度和更多的相移。 4.分配十四.实验数据十五.实验的流程十六.实验结果 结论—作者得出了什么结论十七.结论—这篇文章存在哪些缺陷（还存在哪些问题待解决）十八.陌生单词optimal 最佳的，最理想的sliding 滑动的cross-correlation 互相关metrics 度量inner-product 内积/点积Fourier 傅里叶convolution 卷积theorem 定理signal 信号process 处理scaling 缩放warp 扭曲briefly 简略地estimation 估计compute 计算vector 向量stride 步幅residuals 残差preserve 保存deviate 偏离unit variance 单位方差normalized 标准化的clustering 聚类cluster 集群anomaly 异常robust 健壮的monitor 监控a large number 大量的indicator 指标detect 检测detection 检测anomaly detection 异常检测millions 数百万overhead 开销parameter 参数tuning 调整amplitude 振幅tackle 应对，处理consist 组成preprocessing 预处理baseline 基线，基准extractio 提取assignment 分配technique 技术underlying 潜在的evaluation 评价state-of-the-art 最先进的relevant 相关的overload 超负荷external 攻击implicit 含蓄的group 把…分组homogeneous 同种类的identify 识别server 服务器aforementioned 前面提及的streaming 流aggregate 聚集，集合pre-defined 预定义的interval 间隔，区间essentially 本质上assumption 假设idealized 理想的dimensional 空间的，尺寸的low-dimensional 低维curves 曲线abnormal 异常的pattern 模式variations 变化distort 扭曲tens of thousands 数万个span 跨度periodicity 周期性seasonality 季节性eliminate 排除normalized 标准化computational 计算的efficiency 效率validate 证实，验证outperform 超越dataset 数据集overview 概述denote 表示period 周期notable 显著的fluctuation 起伏deviation 误差scale 规模horizontally 水平地explicit 清楚的phase 阶段lag 落后raw data 原始数据hence 因此detect 检测coherent 相干的sample 采样，样本sake 目的subset 子集linear 线性的interpolation 插入adjacent 邻近的point-wise 逐点的mean 均值standard deviation 标准差demonstrate 展示rough 粗略的moving average 移动平均值","categories":[{"name":"科研","slug":"科研","permalink":"https://hemiaomiao.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://hemiaomiao.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"KPI异常检测","slug":"KPI异常检测","permalink":"https://hemiaomiao.github.io/tags/KPI%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"}],"author":"Miaomiao"},{"title":"KPI异常检测论文","slug":"KPI异常检测论文","date":"2022-03-08T11:58:12.000Z","updated":"2022-03-08T11:58:12.839Z","comments":true,"path":"2022/03/08/KPI异常检测论文/","link":"","permalink":"https://hemiaomiao.github.io/2022/03/08/KPI%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E8%AE%BA%E6%96%87/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://hemiaomiao.github.io/tags/tag1/"}],"author":"Miaomiao"},{"title":"深度学习的基础知识","slug":"深度学习基础知识","date":"2022-03-02T02:01:47.000Z","updated":"2022-03-04T13:05:45.984Z","comments":true,"path":"2022/03/02/深度学习基础知识/","link":"","permalink":"https://hemiaomiao.github.io/2022/03/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"梯度下降法是一种致力于找到函数极值点的算法 梯度梯度表明损失函数相对参数的变化率 泛化误差模型在新数据上的误差 降维1.特征选择2.PCA 主成分分析欠拟合在训练数据上错误率比较高，模型不能很好地拟合数据 过拟合在训练数据上错误率低，在测试数据上错误率很高 抑制过拟合的方法：正则化 dropout 丢弃法1.是一种在学习的过程中随机删除神经元的方法 1.丢弃法将一些输出项随机置0来控制模型复杂度 2.常作用在多层感知机的隐藏层输出上 损失函数1.交叉熵损失函数(1) 交叉熵刻画的是实际输出与期望输出的距离，也就是交叉熵的值越小，两个概率分布就越接近 (2) 目标值需要进行one-hot编码，能与概率值一一对应 神经元（感知机）1.概念 神经元模型是一个包含权重的输入，并且使用激活功能产生输出信号的基础计算单元，包括三个部分：输入、激活、输出 激活部分一般由两模块组成：第一个模块是对输入部分进行加权求和，并且加入偏置项之后得到的结果进行如公式所示的表征函数f()转换处理 第二个模块是对f()处理后的结果进行激活，常用的激活函数有：sigmoid函数等 激活函数激活函数是加权输入和神经元输出的简单映射 softmax函数把神经网络的输出转化成概率 全连接任意一个神经元和前后层的所有神经元相连接 多层感知机（神经网络）是一种前馈人工神经网络模型，其将输入的多个数据集映射到单一的输出的数据集上，传统的神经网络有输入层、隐藏层、输出层，其中隐藏层的层数根据需要而定 卷积神经网络 CNN包括输入层，隐藏层（包含：卷积层、激活层、池化层），输出层（全连接层） 1.卷积层（Convolution)(1) 卷积层的作用是特征提取 (2) 每层卷积层是由若干个卷积单元（卷积核 Convolution Kernel，又称 滤波器 Filter）组成 (3) 组成卷积核的每个元素都有与之对应的偏置和权重系数 (4) 卷积的过程就是待卷积区域与卷积核点乘并加上偏置后的激活输出 (5) 卷积核的填充（padding） 在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据（比如0等） (6) 卷积层的输出也称为特征映射（feature map） 2.池化层（Polling）(1) 池化层的作用是对由卷积层的输出进行信息过滤和特征提取 (2) 最大池化：是从目标区域中取出最大值 3.全连接层（Full Connection）起分类器的作用 循环神经网络 RNN在时间t，模型输出值Yt取决于两个参数：隐藏层到输出层的连接权重Wy和当期状态值Ht， 输入值Xt和上期的状态值Ht-1通过相应的连接权重Wh和Wx，加权相加，再通过激活函数TanH，生成当期的状态值Ht,而Ht在下期计算中又会作为状态输入值与Xt+1一起参与到Ht+1的计算 循环神经网络的优化问题1.梯度消失 2.梯度爆炸 3.长时依赖 LSTM 长短时记忆网络主要是解决循环神经网络RNN存在的梯度消失和梯度爆炸的问题，LSTM的结构和标准RNN类似，区别是LSTM把隐藏层的每个普通节点换成了一个记忆细胞，具备选择性记忆的功能，可以选择记忆重要信息，过滤掉噪声信息,减轻记忆负担 3个Sigmoid函数，两个Tanh函数，Sigmoid函数可以返回0到1区间的值，TanH可以返回-1到1区间的值，3个Sigmoid函数分别管理着三扇门：遗忘门、输入门、输出门 本期记忆状态值Ct由上期状态记忆值Ct-1通过遗忘门过滤到本期的部分加上本期新增的部分，上期过滤的部分是依靠遗忘门，当遗忘门的值为0时意味着上期记忆完全遗忘，当遗忘门的值为1时，上期记忆全部保留 输出门的Sigmoid函数和当期记忆值Ct的TanH值相乘，得到本期的输出值Ht，Ct和Ht会循环流入到t+1时刻参与到下期的计算 门控循环单元GRU两个Sigmoid函数代表两扇门：更新门、重置门 计算当期状态值Ht时，同时考虑历史信息部分和新增信息部分，更新门确定着上期状态能进入到当期的比例，当它与上期状态值Ht-1相乘，就得到了新状态中历史信息的部分 重置门决定了上期信息的遗忘比例，它与上期状态Ht-1相乘，并且和当期输入信息部分Xt相加，再通过TanH函数转化得到当期信息数据，当期信息数据和对应比例(1-Zt)相乘，得到新状态中新增信息的部分 历史信息部分和新增信息部分相加得到最终当期状态值 注意力机制 Attention Mechanism自编码器 AE变分自编码器 VAEseq2seq 编码器和解码器生成对抗网络 GAN生成器（G）试图将输入的噪声转换为假样本，试图欺骗鉴别器（D），而鉴别器（D）试图区分数据是真实的样本还是来自生成器（G）的假样本，在训练迭代过程中，生成器和鉴别器持续地进化和对抗，直到达到平衡状态，鉴别器无法识别出生成器的假样本，训练结束 深度卷积生成对抗网络 DCGAN","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"https://hemiaomiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"Miaomiao"},{"title":"Matplotlib基础知识","slug":"Matplotlib基础知识","date":"2022-01-18T02:17:02.000Z","updated":"2022-01-20T09:51:08.270Z","comments":true,"path":"2022/01/18/Matplotlib基础知识/","link":"","permalink":"https://hemiaomiao.github.io/2022/01/18/Matplotlib%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"一.导包import matplotlib.pyplot as plt 二.图形风格1.表示颜色的字符参数 蓝色: b 绿色: g 红色: r 青色: c 品红: m 黄色: y 黑色: k 白色: w 2.表示类型的字符参数 实线：’-‘ 虚线： ‘–’ 虚点线： ‘-.’ 点虚线： ‘:’ 点： ‘.’ 三.Matplotlib三层结构1.容器层 画板层（canvas）：位于最底层，用户接触不到 画布层（figure）：建立在画板层之上，画布层是指整个图像，通过 plt.figure(figsize=, dpi=)设置画布的大小和分辨率 绘图区 / 坐标系 (axes) ：建立在画布层之上，figure,axes = plt.subplots(nrows=, ncols=, figsize=, dpi=) 辅助显示层和图像层建立在 绘图区/坐标系（axes）之上 一个画布figure可以包含多个（绘图区/坐标系）axes，但是一个axes只能属于一个figure 一个（绘图区/坐标系）axes可以包含多个坐标轴axis，包含2个就是2d坐标系，3个就是3d坐标系 2.辅助显示层辅助显示层主要包括 绘图区/坐标系（axes）的外观、边框线（spines）、坐标轴（axis）、坐标轴名称（axis label）、坐标轴刻度（tick）、坐标轴刻度标签（tick label）、网格线（grid）、图例（legend）、标题（title） 修改x轴的刻度：plt.xticks() 修改y轴的刻度：plt.yticks() 添加描述信息：plt.title()、plt.xlabel()、plt.ylabel() 添加网格：plt.grid() 显示图例：plt.legend() 3.图像层设置图像的颜色、风格 折线图：plt.plot() 散点图: plt.scatter() 柱状图: plt.bar() 直方图: plt.hist() 饼图：plt.pie() 四.单个子图（面向过程）1.步骤(1) 准备数据：x=，y= (2) 创建画布：plt.figure(figsize=(,), dpi=) figsize：图的长宽 dpi：图像的分辨率 (3）保存图片到指定路径: plt.savefig(“path”) (4) 绘制图像：plt.plot(x，y,color=””,linestyle=””,label=””,linewidth=) 如果省略x,plot(y): 表示x默认是从0到N-1 linestyle是线的风格 label是图例的文字 (5) 显示图像：plt.show( ) 2.自定义x、y的刻度 x轴的刻度：plt.xticks(x, **kwargs) y轴的刻度：plt.yticks(y, **kwargs) kwargs是刻度对应的文字说明 3.添加网格显示plt.grid(True,linestyle=’’, alpha=) 4.添加描述信息(1) x轴描述信息：plt.xlabel(“时间”) (2) y轴描述信息：plt.ylabel(“温度”) (3) 标题：plt.title(“中午11点0分到12点之间的温度变化图示”) 5.同一个坐标系下画多个图形多次plt.plot 6.显示图例(1) 在plot里面增加label=”” (2) plt.legend(loc=”best”) import matplotlib. pyplot as plt import numpy as np x = range(60) # 1.准备数据x、y y_shanghai = [np.random.uniform(15,18) for i in x] y_beijing = [np.random.uniform(1, 3) for i in x] plt.figure(figsize=(20,8), dpi=80) # 2.创建画布 plt.plot(x, y_shanghai, color=\"r\", linestyle = \"--\", label = \"shangHai\") # 3.绘制图像，第一个图像 plt.plot(x, y_beijing, color = \"b\", label = \"beiJing\") # 第二个图像 plt.legend(loc=\"best\") # 4.显示图例 x_label = ['one', 'two', 'three', 'four', 'five'] # x的刻度说明 plt.xticks([0, 15, 30, 45, 60], x_label) # 修改x刻度 plt.yticks(range(0, 40, 5)) # 修改y刻度 plt.grid(linestyle = \"--\", alpha = 0.5) #添加网格显示 plt.xlabel(\"timeChange\") #添加x轴描述信息 plt.ylabel(\"wenDu\") # 添加y轴描述信息 plt.title(\"test\" ) # 添加标题 plt.show( ) # 显示图像 五.单个子图（面向对象的画法）2.步骤(1) 准备数据：x=，y= (2) 创建画布：fig,ax = plt.subplots() (3）保存图片到指定路径: plt.savefig(“path”) (4) 绘制图像：ax.plot(x，y,color=””,linestyle=””,label=””) 如果省略x,plot(y): 表示x默认是从0到N-1 linestyle是线的风格 label是图例的文字 (5) 显示图像：plt.show( ) 2.自定义x、y的刻度 x轴的刻度：ax.set_xticks(x) x轴的刻度对应的文字说明：ax.set_xticklabels() y轴的刻度：ax.set_yticks(y) y轴的刻度对应的文字说明：ax.set_yticklabels() 3.添加网格显示ax.grid(True,linestyle=’’, alpha=) 4.添加描述信息(1) x轴描述信息：ax.set_xlabel(“时间”) (2) y轴描述信息：ax.set_ylabel(“温度”) (3) 标题：ax.set_title(“中午11点0分到12点之间的温度变化图示”) 5.显示图例(1) 在plot里面增加label=”” (2) ax.legend(loc=”best”) plt.函数名()是面向过程的画图方法，axes.set()_方法名是面向对象的画图方法 import matplotlib. pyplot as plt import numpy as np x = range(60) # 1.准备数据x、y y_shanghai = [np.random.uniform(15,18) for i in x] y_beijing = [np.random.uniform(1, 3) for i in x] fig,ax = plt.subplots(figsize=(20,8), dpi=80) # 2.创建画布 ax.plot(x, y_shanghai, color=\"r\", linestyle = \"--\", label = \"shangHai\") # 3.绘制图像，第一个图像 ax.plot(x, y_beijing, color = \"b\", label = \"beiJing\") # 第二个图像 ax.legend(loc=\"best\") # 显示图例 x_label = ['one', 'two', 'three', 'four', 'five'] # x的刻度说明 ax.set_xticks([0, 15, 30, 45, 60]) # 修改x刻度 ax.set_xticklabels(x_label) # 设置x的刻度说明 ax.set_yticks(range(0, 40, 5)) # 修改y刻度 ax.grid(linestyle = \"--\", alpha = 0.5) #添加网格显示 ax.set_xlabel(\"timeChange\") #添加描述信息 ax.set_ylabel(\"wenDu\") ax.set_title(\"test\" ) plt.show( ) # 显示图像 六.多个子图（面向对象的画法）2.步骤(1) 准备数据：x=，y= (2) 创建画布：fig,ax = plt.subplots(nrows=, ncols=, *fig_kw) 创建一个带有多个axes(坐标系/绘图区)的图 nrows: subplot的行数 ncols: subplot的列数 *fig_ kw: 创建figure时的其他关键字，例如plt.subplots(2,2,figsize=(8,6)) (3）保存图片到指定路径: plt.savefig(“path”) (4) 绘制图像：ax[i].plot(x，y,color=””,linestyle=””,label=””)，i从0开始 如果省略x,plot(y): 表示x默认是从0到N-1 linestyle是线的风格 label是图例的文字 (5) 显示图像：plt.show( ) 2.自定义x、y的刻度 x轴的刻度：ax[i].set_xticks(x) x轴的刻度对应的文字说明：ax[i].set_xticklabels() y轴的刻度：ax[i].set_yticks(y) y轴的刻度对应的文字说明：ax[i].set_yticklabels() 3.添加网格显示ax[i].grid(True,linestyle=’’, alpha=) 4.添加描述信息(1) x轴描述信息：ax[i].set_xlabel(“时间”) (2) y轴描述信息：ax[i].set_ylabel(“温度”) (3) 标题：ax[i].set_title(“中午11点0分到12点之间的温度变化图示”) 5.显示图例(1) 在plot里面增加label=”” (2) ax[i].legend(loc=”best”) import matplotlib. pyplot as plt import numpy as np x = range(60) # 1.准备数据x、y y_shanghai = [np.random.uniform(15,18) for i in x] y_beijing = [np.random.uniform(1, 3) for i in x] fig,ax = plt.subplots(nrows=1, ncols=2,figsize=(20,8), dpi=80) # 2.创建画布 ax[0].plot(x, y_shanghai, color=\"r\", linestyle = \"--\", label = \"shangHai\") # 3.绘制图像，第一个图像 ax[1].plot(x, y_beijing, color = \"b\", label = \"beiJing\") # 第二个图像 ax[0].legend(loc=\"best\") # 显示图例 ax[1].legend(loc=\"best\") x_label = ['one', 'two', 'three', 'four', 'five'] # x的刻度说明 ax[0].set_xticks([0, 15, 30, 45, 60]) # 修改x刻度 ax[0].set_xticklabels(x_label) # 设置x的刻度说明 ax[0].set_yticks(range(0, 40, 5)) # 修改y刻度 ax[1].set_xticks([0, 15, 30, 45, 60]) # 修改x刻度 ax[1].set_xticklabels(x_label) # 设置x的刻度说明 ax[1].set_yticks(range(0, 40, 5)) # 修改y刻度 ax[0].grid(linestyle = \"--\", alpha = 0.5) #添加网格显示 ax[1].grid(linestyle = \"--\", alpha = 0.5) ax[0].set_xlabel(\"timeChange1\") #添加描述信息 ax[0].set_ylabel(\"wenDu1\") ax[0].set_title(\"test1\" ) ax[1].set_xlabel(\"timeChange2\") #添加描述信息 ax[1].set_ylabel(\"wenDu2\") ax[1].set_title(\"test2\" ) plt.show( ) # 显示图像 七.常见的图像1.折线图 plot：反映数据的变化趋势绘制图像： (1) 面向过程的单个子图：plt.plot(x，y,color=””,linestyle=””,label=””) (2) 面向过程的同一个坐标系下画多个图形: 多次plt.plot (3) 面向对象的单个子图：ax.plot(x，y,color=””,linestyle=””,label=””) (4) 面向对象的多个子图：ax[i].plot(x，y,color=””,linestyle=””,label=””) 2.散点图 scatter：反映变量之间的关联或者点的分布规律绘制图像： (1) 面向过程的单个子图：plt.scatter(x，y,color=””,linestyle=””,label=””) (2) 面向过程的同一个坐标系下画多个图形: 多次plt.scatter (3) 面向对象的单个子图：ax.scatter(x，y,color=””,linestyle=””,label=””) (4) 面向对象的多个子图：ax[i].scatter(x，y,color=””,linestyle=””,label=””) import matplotlib. pyplot as plt x = [225.98, 247.07, 253.14, 457.85, 241.58, 301.01, 20.67, 288.64, 163.56, 120.06, 207.83] y = [196.63, 203.88, 210.75, 372.74, 202.41, 247.61, 24.9, 239.34, 140.32, 104.15, 176.84] fig,ax = plt.subplots(figsize=(20,8), dpi=80) # 2.创建画布 ax.scatter(x,y) ax.grid(linestyle = \"--\", alpha = 0.5) #添加网格显示 ax.set_xlabel(\"X\") #添加x轴的描述信息 ax.set_ylabel(\"Y\") ax.set_title(\"test1\" ) plt.show( ) # 显示图像 3.柱状图 bar：对比绘制图像： (1) 面向过程的单个子图：plt.bar(x，y,color=””,label=””) (2) 面向过程的同一个坐标系下画多个图形: 多次plt.bar (3) 面向对象的单个子图：ax.bar(x，y, width=, color=””,label=””) (4) 面向对象的多个子图：ax[i].bar(x，y, width=, color=””,label=””) import matplotlib. pyplot as plt first_day = [10587.6,10062.5,1275.7] first_weekend = [ 36224.9,34479.6,11830] fig,ax = plt.subplots(figsize=(20,8), dpi=80) # 2.创建画布 ax.bar(range(3), first_day, width=0.2, label=\"FirstDay\") ax.bar([0.2, 1.2, 2.2], first_weekend, width=0.2, label=\"SecondDay\") ax.legend(loc=\"best\") movie_name = [\"one\", \"two\", \"three\"] ax.set_xticks(range(3)) ax.set_xticklabels(movie_name) ax.grid(linestyle = \"--\", alpha = 0.5) #添加网格显示 plt. show() 4.直方图 histogram：分布状况绘制图像： (1) 面向过程的单个子图：plt.hist(x，bins=, normed=, density=True,**kwargs) (2) 面向对象的单个子图：ax.hist(x，bins=, normed=, density=True,**kwargs) (3) 面向对象的多个子图：ax[i].hist(x，bins=, normed=, density=True, **kwargs) density: 是否显示频率 直方图描述的是一组数据的频次分布，是以矩形的长度表示每一组的频数或数量，宽度则表示各组的组距，直方图有助于我们知道数据的分布情况 直方图首先要对数据进行分组，然后统计每个分组内数据的数量,纵轴表示频数，每个矩形的高代表对应的频数 直方图的柱子宽度可以不一样，柱状图的柱子宽度必须一样 直方图Y轴上的变量可以是频次(数据出现了多少次)、频率(频次/总次数)、频率/组距 在绘制直方图的时候需要多次尝试改变组距 组数 bins: 把数据按照不同的范围分组，分成的组的个数称为组数 组距: 每一组两个区间端点的差 组数 bins= (max(time) - min(time)) / 组距 import matplotlib. pyplot as plt time = [131,98,125,131,124,139,131,117,128,108,135,138,131,102,107,114] fig,ax = plt.subplots(figsize=(20,8), dpi=80) distance = 4 group_num = int((max(time) - min(time)) / distance) ax.hist(time, bins=group_num) ax.set_xticks(range(min(time), max(time) + 2, distance)) # 修改x轴的刻度 ax.grid(linestyle = \"--\", alpha = 0.5) #添加网格显示 plt. show() 5.饼图：占比","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Matplotilib","slug":"Matplotilib","permalink":"https://hemiaomiao.github.io/tags/Matplotilib/"}],"author":"Miaomiao"},{"title":"Pandas基础知识","slug":"Pandas基础知识","date":"2022-01-18T02:14:46.000Z","updated":"2022-02-05T14:54:59.797Z","comments":true,"path":"2022/01/18/Pandas基础知识/","link":"","permalink":"https://hemiaomiao.github.io/2022/01/18/Pandas%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"一.导包import pandas as pd 二.Pandas的基本数据结构1.Series带索引的一维数组，和Numpy的一维数组类似，Series要求所有类型相同 一维Series可以用一维列表初始化，默认情况下，Series的下标是数字，类型是统一的 DataFrame是Series的容器 2.DataFrameDataFrame是既有行索引，又有列索引的二维数组，DataFrame是Series的容器，DataFrame要求每一列数据的格式相同 df = pd.DateFrame(数据, index=, columns=) # index是行索引，columns是列索引，索引值从0开始 import numpy as np import pandas as pd stock_change = np.random.normal(0, 1, (5, 4)) pd.DataFrame(stock_change) stock = [\"股票{}\".format(i) for i in range(5)] date = pd.date_range(start=\"20180101\", periods=4, freq=\"B\") df = pd.DataFrame(stock_change, index=stock, columns=date) print(df) 三.DataFrame的属性1.查看类型df.shape 2.查看行索引列表df.index 3.查看列索引列表df.columns 4.查看数据值df.values 5.T6.查看最前面几行的数据（默认是5）df.head() 7.查看最后几行的数据(默认是5)df.tail(num) 四.DataFrame索引的设置1.修改行列索引值df.index= 不能修改单个的索引值 df.index[3]=\"test\" # 错误的 2.重设索引data.reset_index(drop=False) drop:默认为False，不删除原来索引，如果为True,删除原来的索引值 3.以某列值设置为新的索引set_index(keys, drop=True) keys: 列索引名或者列索引名称的列表 drop: 默认是True，当做新的索引，删除原来的列 五.DataFrame的数据操作1.直接使用行列索引（先列后行）df['列索引名', '行索引名'] 2.按名字索引df.loc['行索引名', '列索引名'] 3.按数字索引df.iloc() df.iloc[开始索引, 结束索引] # 是左闭右开的区间[,)，不包括结束索引的数据 4.赋值操作data[\"列名\"] = 值 data.列名 = 值 data.iloc[start, end] = 值 # [start,end) 六.DataFrame的运算1.逻辑运算data[\"p_change\"] &gt; 2 # 返回一组带索引的布尔值 data[(data[\"p_change\"] &gt; 2) &amp;&amp; (data[\"open\"] &gt; 15)] # 筛选 p_change &gt; 2 并且 open &gt; 15 的数据 data.query(条件) 七.Series的创建series结构只有行索引 1.通过已有数据创建(1) 指定内容，默认索引 pd.Series(np.arange(10)) (2) 指定索引 pd.Series([6,7,4,5,1], index=[1,2,3,4,5]) 2.通过字典数据创建pd.Series({'red':100, 'blue':200}) 八.排序1.对内容排序(1) DataFrame df.sort_values(key=, ascending=) # 默认升序 降序：ascending = False升序：ascending = True 单个键：by = “”多个键：by = [“”, “”] (2) Series series.sort_values(ascending=) # series排序时，只有一列，不需要参数 2.对索引排序(1) DataFrame df.sort_index() (2) Series series.sort_index() 九.文件的读取和存储1.CSV(1) 读取数据 pd.read_csv(\"路径\") (2) 存储数据 dataFrame.to_csv(\"路径\", columns=[\"列名\"]) 2.JSONpd.read_json(\"路径\") 十.处理缺失值1.缺失值是np.nan(1) 判断数据中是否有缺失值 pd.isnull(df) # 返回一个布尔值对象 pd.notnull(df) (2) 删除有缺失值的数据 或者 替换/填充缺失值 df.dropna(inplace=False) # 删除含有缺失值的数据 df.fillna(value, inplace=False) # 替换/填充 inplace = True：覆盖之前的数据axis = 0：选择行或者列how = “all”：删除全为空值的行或者列 2.缺失值不是np.nan(1) 把缺失值替换成np.nan df.replace(to_replace=\"?\", value=np.nan) 十一.数据离散化1.对数据进行分组(1) 自动分组 sr = pd.qcut(data, bins) (2) 自定义分组 sr = pd.cut(data, bins) 2.统计每组的个数series.value_counts() 3.将分组好的结果转换成one-hot编码pd.get_dummies(sr, prefix=\"分组名字\") 十二.合并1.按行或列合并pd.concat((data1,data2), axis=) axis=0：列axis=1：行 2.按索引合并pd.merge(left, right, how=\"inner\", on=[索引])","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"https://hemiaomiao.github.io/tags/Pandas/"}],"author":"Miaomiao"},{"title":"numpy基础知识","slug":"numpy基础知识","date":"2022-01-18T02:14:03.000Z","updated":"2022-01-20T11:45:56.557Z","comments":true,"path":"2022/01/18/numpy基础知识/","link":"","permalink":"https://hemiaomiao.github.io/2022/01/18/numpy%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"一.Numpy的作用Numpy用于快速处理任意维度的数组，支持常见的数组和矩阵操作，Numpy提供了一个N维数组类型ndarray，使用ndarry对象处理多维数组 二.导包import numpy as np 三.Numpy数据类型1.布尔型：bool 2.整型：int32，int64，int128 3.浮点数：float32，float64，float，longfloat 4.字符串：string，unicode 5.对象：object 6.时间：datetime64，timedelta64 四.创建数组 / ndarryndarray是N维数组对象 1.创建一维数组(1) np.array([列表]) x = np.array([1,2,3,4,5,6]) (2) 创建数组的时候指定数据类型 np.array([列表], dtype=np.数据类型) x = np.array([1,2,3,4,5,6], dtype=np.float32) 2.创建二维数组嵌套列表 (1) np.array([[列表1],[列表2],...]) X = np.array([[1,2,3,4],[5,6,7,8]]) (2) 创建数组的时候指定数据类型 np.array([[列表1],[列表2],...], dtype=np.数据类型) x = np.array([[1,2,3,4],[5,6,7,8]], dtype=np.float32) np.array()，是深拷贝 深拷贝：只是把值赋值过去，不把两者关联，一个数组的值改变，不会引起另一个数组的值改变 在创建数组 / ndarray的时候，如果没有特别指定，浮点数默认是float64，整数默认是int64 3.创建数组的函数(1)创建全是1的数组:ones np.ones(shape[, dtype=None, order='C]) x = np.ones(6) x = np.ones((2,3)) x = np.ones((2,3), dtype=np.int32) (2) 创建全是0的数组:zeros np.zeros(shape[, dtype=None, order='C]) x = np.zeros(6) x = np.zeros((2,4)) (3) 创建数字序列:arange 区间是左闭右开 [start,stop),不包括stop arange(start, stop, step, dtype) x = np.arange(8) x = np.arange(2,10,2) (4) np.copy() 深拷贝 a = np.array([1,2,3,4]) b = a[2:4] b[0] = 6 # b的值改变，会改变数组a的值 a = np.array([1,2,3,4]) b = a[2:4].copy() b[0] = 6 # b的值改变，不会改变数组a的值 (5) np.asarray(a, dtype=np.数据类型) 浅拷贝 (6) 生成等间隔序列:np.linspace(start, stop, num, endpoint, retstep, dtype) start：序列的起始值 stop：序列的终止值 num:要生成的等间隔样例数量，默认为50 endpoint:如果为true,该值包含于序列中，endpoint序列中是否包含stop值，默认为ture retstep:如果为true,返回样例，以及连续数字之间的步长 dtype:输出ndarray的数据类型 a = np.linspace(0,60,10) (7)创建和数组a形状相同的全是1的数组:zeros_like np.zeros_like(a, dtype=None) (8) 创建和数组a形状相同的全是0的数组:empty_like empty_like(a, dtype=None) (9) 创建指定值的数组:full np.full(shape, value, dtype=None, order='C) x = np.full(4,666) x = np.full((2,4), 666) (10) 创建和数组a形状相同的数组:full_like np.full_like(a, value, dtype=None) 五.ndarray的属性1.数组的形状：ndarray.shape，返回值是一个元组 x = np.array([1,2,3]) x = np.array([[1,2,3],[4,5,6]]) x = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]]) 2.数组中元素的数据类型：ndarray.dtype 3.数组中的元素数量：ndarray.size 4.一个数组元素的长度(字节)：ndarray.itemsize 5.数组的维度的数目：ndarray.ndim 6.数组转置：ndarry.T 7.修改数组的类型： (1) ndarry.astype(np.数据类型) 会返回新的数组，不是引用机制，即新的数组值的改变不会引起之前的数组值改变 a = np.array([1,2,3,4]) b = a.astype(np.float32) b[0] = 0.5 (2) ndarry.tostring() 8.数组a去重：ndarry.unique(a) 六.切片 / 索引切片在内存中是引用机制，切片的修改会修改原来的数组 1.基础索引行索引从0开始，第一行的索引号是0 列索引从0开始，第一列的索引号是0 (1) 一维数组索引 (2) 二维数组索引 a[行索引, 列索引] a[start : end : step, start : end : step]:每一个维度都支持切片，左闭右开的区间[start,end)，不包括end，start和end都是索引号，索引从0开始 a[索引]: 单个索引是索引一整行 a[:, 列索引]: 省略行索引，表示从第一行到最后一行，即 整列 负索引：倒数第几行 / 倒数第几列 2.布尔索引b = a&gt;10 b = a[a&gt;10] a[a&gt;10] = a[a&gt;10] + 5 b = a[:, 3] &gt; 7 # 筛选出第3列的值大于5的行 b = a[a[:, 3] &gt; 7] b = (a%2==0)| (a&gt;7) condition = (a%2==0)| (a&gt;7) b = a[condition] 七.np.where(a)where的返回值是一个元组,返回的是索引位置 b = np.where(a&gt;10) 八.数组和数的运算b = a + 1 b = a / 2 b = a * 3 九.数组和数组的运算1.数组和数组相加c = a + b 2.数组合并(1) np.concatenate((a,b), axis=0)：添加行 c = np.concatenate((a,b)) (2) np.concatenate((a,b), axis=1)：添加列 c = np.concatenate((a,b), axis=1) (3) np.vstack((a,b))：添加行 c = np.vstack((a,b)) (4) np.hstack((a,b)):添加列 c = np.hstack((a,b)) (5) np.row_stack((a,b)):添加行 (6) np.column_stack((a,b)):添加列 2.数组分割np.split(ary, indices_or_sections, axis=0) b = np.split(a, 3) b = np.split(a, [3,5,6,10]) 十.矩阵运算1.矩阵和数组的区别矩阵必须是二维的，数组可以是多维的 2.存储矩阵matrix的方式(1) ndarray二维数组: np.arrary() a = np.array([[80,86], [82,80], [85,78], [90,90], [86,82], [82, 90], [78,80], [92,94]]) (2) matrix数据结构: np.mat(a) a = np.mat([[80,86], [82,80], [85,78], [90,90], [86,82], [82, 90], [78,80], [92,94]]) 3.矩阵乘法 (1) 用ndarray二维数组存储的矩阵：通过np.array()创建的矩阵 np.matmul(a,b) np.dot(a,b) (2) 用matrix数据结构存储的矩阵: 通过np.mat()创建的矩阵 a * b 十一.使用random生成随机数的数组1.np.random.uniform(low=, high=, size=) 在[1ow，high)之间随机采样生成均匀分布的数字 low：采样下界，float类型，默认值是0 high：采样上届，float类型，默认值是1 size：输出样本数目，为int或者元组类型 返回值：ndarray类型，形状和参数size一样 a = np.random.uniform(1,10,10) a = np.random.uniform(1,10,(3,4)) 2.np.random.normal(loc=, scale=, size=) 按照平均值loc和方差scale生成高斯分布的数字 loc是float类型 scale是float类型 a = np.random.normal(1,10,10) a = np.random.normal(1,10,(3,4)) 3.np.random.seed(seed)设定随机种子，这样每次生成的随机数会相同 4.np.random.rand(d0, d1，…. dn)返回在[0,1)之间均匀分布的数 a = np. random.rand(5) a = np. random.rand(3, 4) a = np. random.rand(2, 3, 4) 5.np.random.randn(d0， d1，…. dn)返回数据具有标准正态分布(均值0， 方差1) a = np. random.randn() a = np. random.randn(3) a = np. random.randn(3, 2) a = np. random.randn(3, 2, 4) 6.np.random.randint(low, high， size， dtype)生成随机整数，包含1ow， 不包含high a = np. random.randint(3) a = np. random.randint(1, 10) a = np. random.randint(10, 30, size=(5, )) a = np. random.randint(10, 30, size=(2,3,4)) 7.np.random.random(size)生成[0.0，1.0)的随机数 a = np.random.random (5) a = np.random.random(size=(3,4)) a = np.random.random(size=(2,3,4)) 8.np.random.choice(a,size, replace, p)a是一维数组，从它里面生成随机结果 a = np.random.choice(5, 3) #这时候，a是数字，则从range(5) 中生成，size为3 a = np.random.choice(5, (2,3)) a = np.random.choice([1,2,3,4,5], 3) #这时候，a是数组，从里面随机取出数字 a = np.random.choice([1,2,3,4,5], (2,3)) 9.np.random.shuffle(x)把一个数组x进行随机排列 a = np.arange(10) np.random.shuffle(a) 10.np.random.permutation(x)把一个数组x进行随机排列，或者数字的全排列 a = np.random.permutation(10) #生成range(10)的随机排列 十二.增加数组的维度1.ndarray.reshape(行,列) 或者 np.reshape(a,(行,列))从一维增加到二维，reshape()不会修改原来数组的值，而是返回一个新的数组 x = np.arange(6) x1 = x.reshape(2,3) # 把一维数组变成2行3列的二维数组 等价于 x = np.arange(6).reshape(2,3) a = np.array([1,2,3,4,5,6]) b = np.reshape(a, (2,3)) 2.np.newaxis关键字使用索引的语法给数组添加维度 (1) 给一维向量添加一个行维度 ndarray[np.newaxis, :] a = np.array([0,1,2,3,4]) b = a[np.newaxis, :] (2) 给一维向量添加一个列维度 ndarray[:, np.newaxis] a = np.array([0,1,2,3,4]) b = a[:, np.newaxis] 3.np.expand_dims(arr, axis)axis = 0：代表列 axis = 1：代表行 (1) 给一维向量添加一个行维度 np.expand_dims(ndarray, axis=0) a = np.array([0,1,2,3,4]) print(f\"a.shape={a.shape}\") b = np.expand_dims(a, axis=0) (2) 给一维向量添加一个列维度 np.expand_dims(ndarray, axis=1) a = np.array([0,1,2,3,4]) b = np.expand_dims(a, axis=1) 十三.数学统计函数1.所有元素的和:np.sumb = np.sum(a) 2.所有元素的乘积:np.prodb = np.prod(a) 3.元素的累积加和:np.cumsumb = np.cumsum(a) 4.元素的累积乘积:np.cumprodb = np.cumprod(a) 5.最小值:np.minb = np.min(a) 6.最大值:np.maxb = np.max(a) 7.0-100百分位数:np.percentileb = np.percentile(a, [25,50,75]) 8.0-1分位数:np.quantileb = np.quantile(a, [0.25,0.5,0.75]) 9.中位数:np.medianb = np.median(a) 10.平均值:np.meanb = np.mean(a) 11.加权平均:np.average，参数可以指定weights12.标准差:np.std13.方差:np.var十四.排序1.np.sort(a)2.np.argsort(a)argsort返回从小到大的排列在数组中的索引位置 十五.通用判断函数(1) np.all() 只要有一个False就返回False,只有全是True才返回True (2) np.any() 只要有一个True就返回True,只有全是False才返回False","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hemiaomiao.github.io/tags/Python/"},{"name":"numpy","slug":"numpy","permalink":"https://hemiaomiao.github.io/tags/numpy/"}],"author":"Miaomiao"},{"title":"Python基础知识","slug":"Python基础知识","date":"2022-01-14T06:57:17.000Z","updated":"2022-01-20T11:48:53.978Z","comments":true,"path":"2022/01/14/Python基础知识/","link":"","permalink":"https://hemiaomiao.github.io/2022/01/14/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"一. 安装python解释器 二. 安装PyCharm 三. 调整PyCharm的主题和字体 四. 新建项目 五. 运行项目 六. debug代码dubug的步骤：按F8单步执行，要进入函数的时候按F7，要跳出函数的时候按shift + F8，按F9跳到下一个断点 七. 注释1.单行注释 ( 快捷键 ctrl + / ） # 注释内容 代码 2.多行注释\"\"\" 注释的内容 \"\"\" 八.导入Matplotlib、numpy、pandas 九.命名原则1.小驼峰原则第一个单词的首字母小写，第二个单词的首字母大写，例如firstName 2.大驼峰原则每个单词的首字母都要大写，例如FirstName 十. 输入和输出1. 输入(1) input()让程序暂停运行，等待用户输入信息，获取用户输入后，会赋值给一个变量 (2) int()将字符串转换为整型 2. 输出用print()输出 name = input(\"请输入字符串：\") print(\"用户输入的是：\",name) age = input(\"输入年龄:\") if int(age) &gt; 0: print(f\"{age}\") else: print(f\"不合理\") 十一. 数据类型1.字符串(1) 字符串是以单引号’或双引号”括起来的任意文本 'This is test' \"This is test\" (2) 字符串输出 方法1： print('字符串 + 占位符' % 变量) print('字符串 + 占位符1 + 占位符2' % (变量1,变量2)) 占位符： 字符串：%s 整数：%d 浮点数：%f （ %.2f：显示小数点后2位数 ） 方法2： print(f\"字符串 + {变量1}{变量2}\") age = 18 name = 'Tom' weight = 120.123 student_id = 1 print( \"我的名字是%s\" % name ) print(f\"我的名字是{name}\") print( \"我的学号是%d\" % student_id) print(f\"我的学号是{student_id}\") print( \"我的体重是%.2f斤\" % weight) print( \"我的体重是{weight}斤\") print( \"我的名字是%s，今年%d岁\" % (name, age)) print(f\"我的名字是{name}，今年{age}岁\\n\") (3) 字符串的索引从0开始 (4) 字符串的常用操作 获取字符串的长度： len(字符串) 统计字符串2在字符串里面的出现次数： 字符串.count(字符串2) 从字符串中取出单个字符：字符串[索引] 获取字符串2第一次出现的索引： 字符串.index(字符串) 拆分字符串： 字符串.split() 用连接符合并字符串: “连接符”.join(字符串) 2.整型: int3.浮点型: float4.布尔型: bool5.列表：list(1) 列表在其它语言中通常叫做数组 (2) 列表可以存储不同类型的数据 (3) 列表用 [] 定义，数据之间用 “逗号,” 隔开 (4) 列表的索引从0开始，索引就是数据在列表中的位置编号，索引也称为下标 (5) 列表的常用操作 从列表中取值： 列表[索引] 获取数据第一次出现的索引： 列表.index(数据) 获取列表长度: len (列表) 在末尾追加数据: 列表. append (数据) 修改指定索弓|的数据: 列表[索引]=数据 删除末尾数据: 列表.pop 升序排序: 列表.sort () 在指定位置插入数据: 列表.insert (索引,数据) 将列表2的数据追加到列表: 列表.extend (列表2) 删除第一个出现的指定数据: 列表.remove [数据] 删除指定索弓|数据: 列表.pop (索引) 清空列表: 列表.clear 统计数据在列表中出现的次数: 列表.count (数据) 降序排序: 列表.sort (reverse= True) 逆序 / 反转: 列表.reverse () name_list = [\"zhangsan\", \"Lisi\", \"wangwu\" ] \"\"\"len(length长度)函数可以统计列表中元素的总数\"\"\" list_len = len(name_list) print (\"列表中包含%d个元素\" % list_len) \"\"\"count方法可以统计列表中某一个数据出现的次数\"\"\" count = name_list. count (\"zhangsan\") print(\"zhangsan出现了%d 次\" % count) \"\"\"取值和取索引\"\"\" print (name_list[2]) \"\"\"知道数据的内容，想确定数据在列表中的位置\"\"\" print (name_list . index(\"wangwu\")) \"\"\"修改\"\"\" name_list[1] = \"李四\" \"\"\"从列表中删除第一次出现的数据，如果数据不存在，程序会报错\"\"\" name_list.remove(\"zhangsan\") print (name_list) \"\"\"append 方法可以向列表的末尾追加数据\"\"\" name_list . append(\"王小二\") \"\"\"insert方法可以在列表的指定索引位置插入数据\"\"\" name_list . insert(1, \"小美眉\") \"\"\"extend方法可以把其他列表中的完整内容，追加到当前列表的末尾\"\"\" temp_list = [\"孙悟空\", \"猪二哥\",\"沙师弟\"] name_list . extend(temp_list) print(name_list) \"\"\"remove 方法可以从列表中删除指定的数据\"\"\" name_list . remove (\"wangwu\") \"\"\"pop方法默认可以把列表中最后一个元素删除\"\"\" name_list . pop() \"\"\"pop方法可以指定要删除元素的索引\"\"\" name_list . pop(3) \"\"\"clear 方法可以清空列表\"\"\" name_list. clear() (6) 列表的循环 name_list = [ 'Tom','Lily','Rose'] i = 0 while i &lt; len(name_list): print(name_list[i] ) i = i + 1 6.元组: tuple(1) 元组用**()**定义 (2) 元组里面的数据不能修改 (3) 元组表示多个元素组成的序列，数据之间使用 “逗号,” 分隔 (4) 元组可以存储不同的数据类型 (5) 元组的索引从0开始,索引就是数据在元组中的位置编号 (6) 元组中只包含一个元素时，需要在元素后面添加”逗号,” info_tuple1 = () # 创建空元组 info_tuple2 = (10, ) # 元组中只包含一个元素时，需要在元素后面添加逗号 info_tuple3 = (\"zhangsan\", 18, 1.75) (7) 元组的常用操作 根据索引从元组中取值：元组[索引] 获取元组的长度：len(元组) 获取数据在元组中出现的次数：元组.count(数据) 获得数据在元组中第一次出现的索引：元组.index(数据) info_tuple = (\"zhangsan\", 18, 1.75, \"zhangsan\") print(info_tuple[0]) # 取值 print (info_tuple. index (\"zhangsan\")) #已经知道数据的内容，希望知道该数据在元组中的索引 print (info_tuple. count (\"zhangsan\")) # 疏计计数 print (len(info_tuple)) # 统计元组中包含元素的个数 注： 列表和元组的转换 使用list函数可以把元组转换成列表：list(元组) 使用tuple函数可以把列表转换成元组：tuple(列表) 7.集合: set(1) 集合用**{}或者set()**定义，如果创建空集合只能用set() (2) 集合的数据是无序的，不支持下标访问 (3) 集合没有重复元素 test1 = {\"java\",\"c\"} test2 = {1,2,3,4} (4) 集合的常见操作 添加数据：add() 添加的数据是序列: update() 删除数据：remove() s1 = {10,20} s1.add(30) print(s1) s1.update([40,50]) s1.update('abc') print(s1) s1.remove(10) print(s1) 8.字典:dict(1) 字典用**{}**定义 (2) 字典使用键值对存储数据，键值对之间使用 “逗号,” 分隔 键key是索引 值value 是数据 键key和值value之间使用 “冒号:” 分隔 键必须是唯一的 键只能是字符串、数字或者元组 值可以取任何数据类型 (3) 字典同样可以用来存储不同的数据类型 (4) 循环遍历字典 xiaoming = {\"name\":\"小明\", \"age\":8, \"gender\":True, \"height\": 1.75} print(f\"xiaoming={xiaoming}\") for k in xiaoming.keys(): # 遍历字典 print(f\"k={k},value={xiaoming[k]}\") (5) 遍历字典的元素 xiaoming = {\"name\":\"小明\", \"age\":8, \"gender\":True, \"height\": 1.75} for item in xiaoming.items(): print(item) (6) 遍历字典的键值对 xiaoming = {\"name\":\"小明\", \"age\":8, \"gender\":True, \"height\": 1.75} for key,value in xiaoming.items(): print(f\"key={key},value={value}\") (7) 列表里面嵌套字典 \"\"\"将多个字典放在一个列表中\"\"\" card_list = [{\"name\": \"张三\", \"qq\":\"12345\", \"phone\":\"110\"}, {\"name\":\"李四\", \"qq\" :\"54321\", \"phone\":\"10086\"} ] for card_info in card_list: print (card_info) (8) 字典是一个无序的数据集合，使用print函数输出字典时，通常输出的顺序和定义的顺序是不一致的 (9) 字典不支持下标访问，只能按照键的名字去找值 (10) 字典的常用操作 获取字典的键值对数量：len(字典) 获取所有key列表：字典.keys() 获取所有value列表：字典.values() 获取字典的所有元素 / 所有键值对：字典.items() 根据key值查找：字典[key] (key不存在会报错） 根据key值查找：字典.get(key) (key不存在不会报错） 删除指定键值对：字典.pop(key) 随机删除一个键值对：字典.popitem() 清空字典：字典.clear() 字典[key] = value：如果key存在，修改数据，如果key不存，新建键值对 字典.setdefault(key, value)：如果key存在，不会修改数据，如果key不存在，新建键值对 将字典2的数据合并到字典：字典.update(字典2) xiaoming_dict = {\"name\": \"小明\"} print (xiaoming_dict [\"name\"]) #在取值的时候，如果指定的key不存在，程序会报错! xiaoming_dict[\"age\"] = 18 # 如果key不存在，会新增键值对,如果key已经存在，会修改已经存在的键值对 print(xiaoming_dict) xiaoming_dict[\"name\"] = \"小小明\" print(f\"键值对数量={xiaoming_dict}\") print(len(xiaoming_dict)) # 统计键值对数量 xiaoming_dict.pop (\"name\" ) # 在删除指定键值对的时候，如果指定的key不存在，程序会报错 print (xiaoming_dict) temp_dict = {\"height\": 1.75, \"age\": 20} #注意:如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对 xiaoming_dict.update(temp_dict ) # 合并字典 print(xiaoming_dict) xiaoming_dict.clear( ) # 清空字典 十二.if 和 else的语法if 条件1: 代码 elif 条件2: 代码 else： 代码 注： 1.属于if条件的代码要缩进四个空格，属于elif条件的代码要缩进四个空格，属于else的代码要缩进四个空格 2.if语句以及缩进部分是一个完整的代码块，else语句以及缩进部分是一个完整的代码块 age = int(input( '请输入年龄: ')) if age &lt; 18: print(f\"年龄是{age},童工\") elif 18 &lt;= age &lt;= 60: print(f\"您的年龄是{age},合法工龄\") else: print(f\"您的年龄是{age},可以退休\") 十三.循环(1) while循环定义计数器 while 条件: 在循环内部执行的代码 改变计数器的值 注： 1.属于while循环的代码要缩进四个空格 3.while语句以及缩进部分是一个完整的代码块 i = 1 while i &lt;= 3: print( f\"{i}\") i = i + 1 print( f\"{i}\") (2) for循环for 变量 in 列表: 代码 str1 = 'ihem' for i in / not in str1: if i == 'e': print('遇到e不打印') break print(i) 注： 1.属于for循环的代码要缩进四个空格 2.break某一条件满足时，退出循环，不再执行后续重复的代码 3.cont inue某一条件满足时，不执行后续重复的代码 4.break和continue只针对当前所在循环有效 十四.range()函数1.range(start,end, step)：左闭右开[start,end),生成从start到end-1的数字，不包含end，步长为step for i in range(1, 4, 1): print(i) 2.range(num):生成从0到num-1的数字 （range函数只有一个参数的时候） for i in range(4): print(i) 3.使用range()创建数字列表 list()函数将range()的结果直接转换成列表 number1 = list(range(1, 4)) print(number1) number2 = list(range(4)) print(number2) number3 = list(range(1,10,2)) print(number3) 十五.列表解析 / 列表生成式列表解析：把for循环和创建新元素的代码合并成一行 square = [value * 2 for value in range(1,5)] # 把1到4的数字提供给表达式value*2， print(f\"square={square}\") 等价于 square = [] for value in range(1,5): square.append(value * 2) print(f\"square={square}\") 十六.切片1.切片适用：字符串、列表、元组 2.切片的格式(1) 字符串/列表/元组[开始索引:结束索引:步长] (2) 切片的区间是左闭右开：[开始索引，结束索引)，从开始索引到结束索引的前一位，不包括结束索引 (3) [ ：结束索引]：省略开始索引，表示默认从索引0(第一个元素)开始 (4) [开始索引: ]：省略结束索引，表示默认到最后一个元素结束 (5) [开始索引：结束索引]:省略步长，表示步长默认是1 (6) [ : ]:省略开始索引和结束索引，表示复制列表，从第一个元素到最后一个元素 (7) [ : ： step]:省略开始索引和结束索引，从第一个元素到最后一个元素，步长为step (8) 如果步长是-1，表示从右向左切片 (9) 索引是负数：表示倒数第几个元素，-1表示倒数第一个元素，-3表示倒数第三个元素 (10) 开始索引是负数：表示从倒数第几个元素开始，是包括倒数第几个元素 (11) 结束索引是负数：表示到倒数第几个元素之前的元素，不包括倒数第几个元素，因为区间是左闭右开 num_str = \"abcde\" print(f\"num_str={num_str}\") print(f\"num_str[2:5]={num_str[2:5]}\") # 从索引2到索引5，即第3个元素到第5个元素 print(f\"num_str[2:]={num_str[2:]}\") # 从索引2到最后一个元素，即第3个元素到最后一个元素 print(f\"num_str[:5]={num_str[:5]}\") # 从索引0到索引4，即从第1个元素到第5个元素 print(f\"num_str[:]={num_str[:]}\") # 从第1个元素到最后1个元素 print(f\"num_str[::2]={num_str[::2]}\") # 从第1个元素到最后1个元素，步长是2 print(f\"num_str[1::2]={num_str[1::2]}\") # 从索引1到最后1个元素，即从第2个元素到最后1个元素，步长是2 print(f\"num_str[2:-1]={num_str[2:-1]}\") # 从索引2到倒数第1个元素之前的元素，即从第3个元素到倒数第2个元素，不包括倒数第1个元素 print(f\"num_str[-2:]={num_str[-2:]}\") # 从倒数第2个元素到最后1个元素 print(f\"num_str[::-1]={num_str[::-1]}\") # 从右向左切片 name = \"abcdefg\" print(f\"name={name}\") print(f\"name[2:5:1]={name[2:5:1]}\") print(f\"name[2:5:2]={name[2:5:2]}\") print(f\"name[2:5]={name[2:5]}\") print(f\"name[:5]={name[:5]}\") print(f\"name[1:]={name[1:]}\") print(f\"name[:]={name[:]}\") print (f\"name[::2]={name[::2]}\") print(f\"name[:-1]={name[:-1]}\") print (f\"name[-4:-1]={name[-4:-1]}\") print(f\"name[::-1]={name[::-1]}\") 十七.函数1.函数的定义def 函数名 函数封装的代码 2.函数的调用通过函数名调用函数，如果不主动调用函数，函数是不会执行的 注意： 函数定义要放在函数调用前面 3.函数的注释函数的注释要写在定义函数的下方 注意： 函数定义的上方要有两个空行 def say_hello(): \"\"\" 打招呼 \"\"\" print(\"hello\") say_hello() 4.函数的返回值函数返回多个值： (1) return a,b 返回多个数据的时候，默认是元组类型 (2) return后面可以连接列表、元组或者字典，从而返回多个值 (3) 使用元组可以让函数一次返回多个结果，如果函数的返回值是元组，括号可以省略 def measure(): temp = 39 wetness = 50 return temp, wetness # 省略了元组的括号，本来是 return (temp， wetness) result = measure( ) print ( result) (4) 如果函数返回值是元组，同时希望单独处理元组中的元素，可以使用多个变量，一次接收函数的返回结果,注意：变量的数量需要和元组中的元素数量保持一致 def measure(): temp = 39 wetness = 50 return temp, wetness # 返回值是元祖，所以省略了元祖的括号 gl_temp,gl_wetness = measure() print(gl_temp) print(gl_wetness ) 5.不定长参数 / 可变参数(1) 有时可能需要一个函数能够处理的参数个数是不确定的，这个时候，就可以使用多值参数 (2) python中有两种多值参数: 参数名前增加 * ：接收元组 参数名前增加 ** ： 接收字典 (3) 一般在给多值参数命名时，习惯使用以下两个名字 *args：传进来的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组，args是元组类型 **kwargs：存放字典参数,记忆键值对参数 def demo(num,*args, **kwargs): print( num ) print(args ) print( kwargs) demo(1, 2, 3, 4, 5, name=\"小明\",age=18, gender=True ) 6.元组和字典的拆包(1) 在调用带有多值参数的函数时，如果希望: 将一个元组变量，直接传递给args 将一个字典变量，直接传递给kwargs (2) 就可以使用拆包，简化参数的传递，拆包的方式是: 在元组变量前，增加 * 在字典变量前，增加 ** def demo (*args,**kwargs): print(f\"元组变量args={args}\") print (f\"字典变量kwargs={kwargs}\") nums = (1, 2, 3) # 元组变量 dict = {\"name\": \"小明\", \"age\": 18} # 字典变量 demo(*nums, **dict) 十八.变量的引用1.变量和数据是分开存储的，数据保存在内存中，变量保存着数据在内存中的地址 2.变量中记录数据的地址，就叫做引用 3.如果变量已经被定义，当给一个变量赋值的时候，本质上是修改了数据的引用，变量不再对之前的数据引用，而是改为对新赋值的数据引用 a = 2 print(\"a=%d,a在内存中的地址是%d\" % (a,id(a))) a = 3 print(\"赋值后，a=%d,a在内存中的地址是%d\" % (a,id(a))) b = a print(\"b=%d,b在内存中的地址是%d\" % (b,id(b))) 十九.可变类型和不可变类型(1) 可变类型：内存中的数据能直接修改 (2) 可变类型有： 列表 字典 集合 (3) 如果给可变类型的变量赋值了一个新的数据，引用会被修改：变量不再对之前的数据引用，变量改为对新赋值的数据引用 (4) 不可变类型：内存中的数据不能直接修改 (5) 不可变类型有： 数字型(int、bool、float等) 字符串 元组 二十.局部变量和全局变量1.局部变量(1) 局部变量的定义 局部变量是在函数内部定义的变量，只能在函数内部使用 函数执行结束后，函数内部的局部变量,会被系统回收 不同的函数，可以定义相同的名字的局部变量，但是彼此之间不会产生影响 (2) 局部变量的作用 在函数内部使用，临时保存函数内部需要使用的数据 (3) 局部变量的生命周期 所谓生命周期就是变量从被创建到被系统回收的过程 局部变量在函数执行时才会被创建 函数执行结束后局部变量被系统回收 局部变量在生命周期内，可以用来存储函数内部临时使用到的数据 2.全局变量(1) 全局变量是在函数外部定义的变量，所有函数内部都可以使用这个变量 (2) 为了保证所有的函数都能够正确使用到全局变量，应该将全局变量定义在其他函数的上方 (3) 全局变量名前应该增加g_ 或者g1_的前缀 (4) 在函数内部不允许直接修改全局变量的值，如果在函数内部使用赋值语句修改全局变量的值，只是相当于定义了一个局部变量 #全局变量 num = 10 def demo1(): # 是不允许直接修改全局变量的值 # 如果使用赋值语句，会在函数内部，定义一个局部变量 num = 99 print (\"demo1 ==&gt; %d\" % num) def demo2(): print(\"demo2 ==&gt; %d\" % num) demo1() demo2() (5) 如果在函数中需要修改全局变量，需要使用global进行声明 #全局变量 num = 10 def demo1(): #希望修改全局变量的值.使用global 声明一下变量即可 #global关键字会告诉解释器后面的变量是--个全局变量 #再使用赋值语句时，就不会创建局部变量 global num num = 99 print(\"demo1 ==&gt; %d\" % num) def demo2() : print(\"demo2 ==&gt; %d\" % num) demo1() demo2() def demo (num_list): print (\"函数内部的代码\") #在函数内部，针对参数使用赋值语句，不会修改到外部的实参变量 num = 100 num_list = [1, 2, 3] print(num_list) print(\"函数执行完成后\") gl_list = [4, 5, 6] demo(gl_list) print(gl_list) def demo(num_list): print (\"函数内部的代码\") #使用方法修改列表的内容 num_list. append(9) print(num_list) print (\"函数执行完成\") gl_list = [1,2,3] demo(gl_list) print(gl_list) 注意: 函数执行时，需要处理变量时会: 1.首先查找函数内部是否存在指定名称的局部变量,如果有，直接使用 2.如果没有，查找函数外部是否存在指定名称的全局变量，如果有，直接使用 3.如果还没有,程序报错! 二十一.模块1.导入模块的方式 import 模块名 import 模块名1,模块名2,… from 模块名 import 功能名 from 模块名 import 功能名1,功能名2,… from 模块名 import * import 模块名 as 别名 from 模块名 import 功能名 as 别名 别名要符合大驼峰原则 2.调用功能模块名.功能名() 3.制作自定义模块python中每个文件都可以作为一个模块，模块的名字就是文件的名字 (1) 只在当前文件中执行测试代码，其它导入该模块的文件不执行测试代码 (2) 测试代码格式： if __name__ == '__main__': 调用模块里面的函数 def testA(a, b): # 在 my_module1.py文件中定义模块和测试模块 print(a + b) if __name__ == '__main__': testA(1,1) (4) 调用模块 import my_module1 my_module1.testA(1，1) 二十二.包1.导入包(1) 方法1 导入包：import 包名.模块名 调用：包名.模块名.目标 (2) 方法2 导入包： 1.from 包名 import * 2.在包内部的init.py文件添加all == []，控制允许导入的模块列表 调用：模块名.目标 \"\"\" 新建一个包my_package,在包里面添加模块my_module.py，模块内代码如下：\"\"\" def info_print(): print(\"test\") 方法1： \"\"\"导入包里面的模块\"\"\" import my_package.my_ module \"\"\"调用模块里面的方法\"\"\" my_package.my_ module.info_print() 方法2： 在__init__.py文件中添加__all__ = [] \"\"\"导入包里面的模块\"\"\" from my_package import * \"\"\"调用模块里面的方法\"\"\" my_module.info_print( ) 二十三.类和对象1.定义类:类名要符合大驼峰原则 (首字母大写)class 类名(): def 函数(self,参数列表): pass 类里面定义的函数必须有self,self是调用该函数的对象 类里面的代码是：class下面缩进的代码 class Person: def run(self): print(\"调用Person类里面的run方法\") xiaoming = Person() xiaoming.run() 2.创建对象（实例对象）对象名 = 类名() 创建对象的动作叫作实例化 对象的属性叫做实例属性 对象调用的方法叫做实例方法 在程序执行的时候，对象可以通过self.访问自己的属性和调用自己的方法 3.selfself：是调用该函数的对象，哪一个对象调用的函数，self就是哪一个对象的引用 4.调用类里面的函数对象名.函数() 5.获取属性(实例属性）(1) 类外面获取对象属性 对象名.属性名 (2) 类里面获取对象属性 self.属性名 属性要封装在类的内部 在类的外部，通过 “变量名.” 访问对象的属性和方法 在类封装的方法中，通过 “self.” 访问对象的属性和方法 6.初始化方法 __init__方法__init__方法是专门用来定义一个类具有哪些属性的方法 __init__在创建对象的时候会自动被调用 (1) 当使用类名()创建对象时，会自动执行以下操作: 1.在内存中为对象分配空间和返回对象的引用：使用__new__方法 2.为对象的属性设置初始值：调用初始化方法(__init__方法) (2）不带形参的__init__方法 在__init__方法内部定义属性：self.属性名 = 初始值 定义属性之后，再使用类名创建的对象都会拥有该属性 格式： class Cat: def __init__ (self): pass 对象名 = 类名() # #使用类名( )创建对象的时候，会自动调用初始化方法__init__ 注： init(self) 中的self参数，不需要开发者传递，python解释器器会自动把当前的对象引用传递过去 class Cat: def __init__ (self): print(\"这是个初始化方法\" ) self.name = \"Tom\" # 定义用Cat类创建的对象都有name属性 def eat(self): # slef是调用方法的对象，即 tom print(f\"{self.name}\") tom = Cat() # #使用类名( )创建对象的时候，会自动调用初始化方法__init__ tom.eat() (3) 带形参的init()方法 如果希望在创建对象的同时，就设置对象的属性： 把希望设置的属性值，定义成__init__方法的参数 在__init__方法内部定义属性: self.属性 = 形参 在创建对象时，使用类名(属性1的值，属性2的值，…)调用 class Cat: def __init__ (self, name): print(\"这是个初始化方法\" ) self.name = name # 接收传递的参数 def eat(self): # slef是调用方法的对象，即 tom print(f\"{self.name}\") tom = Cat(\"Tom\") # #使用类名( )创建对象的时候，会自动调用初始化方法__init__ tom.eat() 7.__str__方法(1) __str__方法可以让print输出对象的时候，输出的是__str__方法的返回值 (2) 如果没有__str__方法，当用print输出对象的时候，是输出对象是由哪个类创建的和对象在内存中的地址 class Cat: def __init__ (self, name): self.name = name tom = Cat(\"Tom\") print(tom) class Cat: def __init__ (self, name): self.name = name def __str__(self): return \"是: %s\" % self.name tom = Cat(\"Tom\") print(tom) class Person: def __init__(self, name, weight): print(\"__init__方法\") self.name = name self.weight = weight def __str__(self): return \"__str__方法:%.2f斤\" % (self .weight) def run(self): print(\"run方法:%s跑步\" % self.name ) xiaoming = Person(\"小明\", 75) xiaoming.run( ) print(xiaoming) 8.私有属性和私有方法(1) 定义私有属性：在属性前面增加两个_ (2) 定义私有方法：在方法前面增加两个_ (3) 对象不不能访问私有属性和私有⽅方法，在类的外部访问不到私有属性和私有方法 (4) 子类⽆无法继承⽗父类的私有属性和私有⽅方法 (5) 获取私有属性: 定义函数get_xx (6) 修改私有属性的值: 定义函数set_xx class Women : def __init__ (self, name): self.name = name self.__age = 18 # 私有属性 print(f\"私有属性__age={self.__age}\") def __secret(self): # 私有方法 print(f\"年龄是{self.__age}\") xiaofang = Women(\"小芳\") class Women : def __init__ (self): self.__age = 8 # 私有属性 print(f\"私有属性__age={self.__age}\") def set_age(self): # 修改私有属性 self.__age = 1 print(f\"修改后私有属性__age={self.__age}\") def get_age(self): # 获取私有属性 return self.__age xiaofang = Women() xiaofang.set_age() age = xiaofang.get_age() print(f\"返回的私有属性__age={age}\") 二十四.类属性和类方法1.概念 类是一种特殊的对象，”class 类名”定义的类是类对象 类对象在内存中只有一份，一个类可以创建多个实例对象 类对象可以拥有自己的属性和方法，称为类属性和类方法 通过”类名.”可以访问类属性和调用类方法 2.类属性类属性用来记录和类相关的特征 class Tool(object): count = 0 # 类属性 def __init__ (self, name): self.name = name # 对象的属性，即 对象的实例属性 Tool. count = Tool. count + 1 tool1 = Tool(\"斧头\") tool2 = Tool(\"榔头\") print(f\"类属性Tool.count={Tool.count}\") 二十五.面向对象三大特性1.封装是把属性和方法封裝到一个类里面 2.继承实现代码的重用，相同的代码不需要重复的编写 3.多态不同的对象调用相同的方法，产生不同的结果 二十六.继承1.单继承 (1) 继承：子类拥有父类以及父类的父类中封装的所有非私有属性和非私有方法 (2) 格式： class 子类名(父类名): pass (3) 方法的重写 当父类的方法不能满足子类需求时，子类可以对方法进行重写 重写之后，在运行中只会调用子类中重写的方法，不会调用父类的同名方法 重写之后，子类调用父类的同名方法，在子类里面使用”super().函数()” 子类和父类具有同名属性和方法，默认使用子类的同名属性和同名方法 class Master(object) : # 父类 def __init__(self): self.feel = \"开心\" def make_cake(self): print(f\"父类里面feel={self.feel}\") class Prentice(Master): # 子类 def __init__(self): self.feel = \"悲伤\" def make_cake(self): print(f\"子类里面feel={self.feel}\") def father(self): super().make_cake() son = Prentice( ) son.make_cake() son.father() 2.多继承 (1) 子类同时继承了多个父类 (2) 格式： class 子类名(父类名1, 父类名2, ...): pass 二十七.多态(1) 子类重写父类的方法，不同子类的对象调用和父类同名的方法，可以得到不同的结果 (2) 实现步骤： 定义父类，并提供公共方法 定义子类,并重写父类方法 传递子类对象给调用者，可以看到不同子类执行效果不同 class Dog(object): # 定义父类 def __init__(self, name): self.name = name def game(self): print(f\"Dog类的name={self.name}\") class FirstDog(Dog): # 定义子类1 def game(self): # 重写父类的方法 print(f\"FirstDoag类的name={self.name}\") class SecondDog(Dog): # 定义子类2 def game(self): # 重写父类的方法 print(f\"SecondDoag类的name={self.name}\") class Person( object) : def with_dog(self, dog): # 传入不同的对象，执行不同的代码，即不同的work函数 print(\"Person类里面\") dog.game() firstDog = FirstDog(\"子类1\") secondDog = SecondDog(\"子类2\") person = Person( ) person.with_dog(firstDog) person.with_dog(secondDog) 二十八.异常1.捕获异常的格式：try: 可能发生错误的代码 except 错误类型1: 发生错误类型1，执行的代码 except 错误类型2: 发生错误类型2，执行的代码 except Exception as result: 捕获未知错误，执行的代码 print( result) else: 没有异常才会执行的代码 finally: 无论是否有异常，都会执行的代码","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://hemiaomiao.github.io/tags/Python/"}],"author":"Miaomiao"},{"title":"智能运维的论文","slug":"智能运维的论文","date":"2021-11-20T18:44:48.000Z","updated":"2021-11-28T10:05:47.860Z","comments":true,"path":"2021/11/21/智能运维的论文/","link":"","permalink":"https://hemiaomiao.github.io/2021/11/21/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4%E7%9A%84%E8%AE%BA%E6%96%87/","excerpt":"","text":"1.基于机器学习的智能运维 论文传送门 2.《智能运维：从0搭建大规模分布式AIOps系统》","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"智能运维","slug":"智能运维","permalink":"https://hemiaomiao.github.io/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/"},{"name":"论文","slug":"论文","permalink":"https://hemiaomiao.github.io/tags/%E8%AE%BA%E6%96%87/"}],"author":"Miaomiao"},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2021-11-20T14:40:26.000Z","updated":"2022-01-17T03:17:53.135Z","comments":true,"path":"2021/11/20/Linux常用命令/","link":"","permalink":"https://hemiaomiao.github.io/2021/11/20/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"从windows上传文件：在Linux命令行下输入： rz 输入rz命令后，会弹出对话框，选择你要上传的文件，选择打开就上传到Linux主机，文件会被长传到当前命令行所在的目录下 查看上传的文件：在Linux命令行下输入： ls 从Linux主机下载文件：在Linux命令行下输入： sz 文件名 解释： rz中的r意为received（接收），告诉客户端，服务器要接收文件，就等同于客户端在上传 sz中的s意为send（发送），告诉客户端，服务器要发送文件，就等同于客户端在下载 Linux文件与目录管理的命令 ls (列出目录)： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 例如：将家目录下的所有文件列出来(含属性与隐藏档): ls -al mkdir (创建新目录)：mkdir [-m/-p] 目录名称 -m ：配置文件的权限,没有加上 -m 来强制配置属性，系统会使用默认属性 -p ：创建多层目录 rmdir (删除空的目录):rmdir [-p] 目录名称 -p ：从该目录起，一次删除多级空目录 注意 rmdir 仅能删除空的目录，使用 rm 命令来删除非空目录 例如：删除AIOps目录： rmdir AIOps","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hemiaomiao.github.io/tags/Linux/"}],"author":"Miaomiao"},{"title":"Xshell连接Linux服务器","slug":"Xshell连接Linux服务器","date":"2021-11-20T14:40:03.000Z","updated":"2021-11-20T15:25:00.896Z","comments":true,"path":"2021/11/20/Xshell连接Linux服务器/","link":"","permalink":"https://hemiaomiao.github.io/2021/11/20/Xshell%E8%BF%9E%E6%8E%A5Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hemiaomiao.github.io/tags/Linux/"}],"author":"Miaomiao"},{"title":"左神算法视频学习笔记","slug":"左神算法视频学习","date":"2021-11-04T09:25:51.000Z","updated":"2021-11-20T07:46:57.458Z","comments":true,"path":"2021/11/04/左神算法视频学习/","link":"","permalink":"https://hemiaomiao.github.io/2021/11/04/%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"一.时间复杂度和空间复杂度 空间复杂度：这个流程需要多少","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://hemiaomiao.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Miaomiao"},{"title":"智能运维","slug":"智能运维","date":"2021-10-28T11:25:52.000Z","updated":"2021-11-20T07:43:04.795Z","comments":true,"path":"2021/10/28/智能运维/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/28/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/","excerpt":"","text":"运维要做的是保障业务能够可靠高速高效安全的运转，因为它会直接影响到业务的收益和成本。目前已有运维方法的主要难点是突发故障的发现、止损、修复和规避，也是我们要解决的关键问题。 当前运维所大量依赖的人力决策已经无法应对当前运维所面临的挑战。随着互联网、移动互联网迅猛发展，用户越来越挑剔、对应用软件的用户体验要求越来越高。应用软件都是建立在一个庞大、复杂、跨协议层的大型分布式系统之上的，而这个分布式系统的技术、软件、配置通常会不断快速地演变; 其软硬件难以避免会发生故障、Bug, 变更，用户流量会发生不可预知的变化，甚至会发生安全攻击事件， 而上述趋势有愈演愈烈之势。 尽管各类运维监控工具使得系统运行状态的可见度有较大提升，但是当遇到运维故障时，面对海量监控数据和庞大负责分布式系统，仍依赖运维人员在高压下人力做出迅速、准确的运维决策，这显然是不现实的。 解决上述核心矛盾的思路就是逐渐减少人力在运维决策中所占的比例，逐渐增加人工智能在运维决策中的比例，最终实现无人运维。 运维已经从最早的人力运维发展到了一定程度上的自动化运维（但是还需要大量人力盯屏决策），最终我们希望基于人工智能的运维工具能够更多自主决策，只需很少人力、甚至不再需要人力参与决策，这就是我们运维行业的长远的目标：基于 AIOps 无人运维。 无人运维是目标，智能运维AIOps（AI for IT Operations） 是工具、手段。 智能运维是指在互联网中的大型分布式系统不断处理海量用户体验、性能、稳定性、安全事件，从而达到如下效果：能够准确的复现并诊断过去发生的事件；能够及时准确的检测、诊断当前正在发生的事件，并确定最适合的应对方案；能够相对准确地规划和预测将来可能发生的事件。因此可以看出智能运维是人工智能（机器学习）、互联网运维领域知识、工程开发的交叉领域，三者缺一不可。 智能运维是人工智能（机器学习）、互联网领域知识、工程的交叉领域。互联网领域技术和工程开发技术在此不赘述。智能运维常用到的机器学习技术包括相关性分析、回归、关联分析、聚类、决策树、随机森林、支持向量机、隐氏马尔科夫、卷积神经网络、LSTM（Long Short Term Memory) 等等。这些算法在各种（开源或闭源的）工具集中都有现成的代码实现。智能运维的一个主要挑战是根据具体需求评判应用哪些机器学习算法，并适配或改造。智能运维正在经历由“基于人为指定规则”到“基于机器学习”的转变 基于如上机器学习技术的具体智能运维技术包括：面向历史事件的： 批量根因分析、瓶颈分析、热点分析等；面向实时事件的： KPI异常检测、日志异常监测、事件关联关系挖掘、报警聚合、快速止损、故障根因分析、止损建议分析；面向未来的：配置管理、容量预测、趋势预测、故障预测、热点预测等。 基于机器学习的智能运维技术是APM（应用性能监控），操作系统性能监控，数据库监控，网络监控等技术的底层基础技术 未来几年的运维领域的技术发展的期望：1.一些智能运维的关键技术会逐渐通过工业界和学术界的密切合作被突破，比如异常检测、异常定位、异常事件关联等。2.更多的预测型的智能运维技术会被提出并实际应用，比如故障预测、热点预测、容量预测等。 容器和微服务的不断落地，也会使得一些过去可行的技术（比如基于人工置顶规则的根因分析）遇到瓶颈，需要新的智能运维技术来适应容器和微服务等底层技术的更新 故障识别也叫故障根因分析（Root Cause Analysis） ，是智能运维领域非常有挑战性的一个工作，主要在于三个原因：1.对各类事件的监控要全面，少了数据不行，实践中很难一下就全面监控各类事件；2.对各类事件的监控要准确，但是很多事件的监控是依赖于异常检测的准确度的，而这个问题还没有在实践中很好解决，往往还是基于原始的静态阈值；3.由于微服务的兴起，模块的更新变化变得很快，模块监控项之间的故障传播关系也在不断变化，导致无法通过先验知识建立静态的故障传播链。 实验室的主要工作重点在问题二和问题三：1.通过集成学习方法实现算法与参数的智能筛选，使得异常检测在实践中不必再手动调算法、调参数，实用性大大提升，使得实践监控变得准确；2.通过关联关系挖掘和随机森林自动挖掘微服务模块间的故障传播链关系。以上都有相应的论文发表，我们还在尝试用最新的机器学习算法来进一步提升相应解决方案的性能。 提出的无人运维量化评级方法，不包含主观因素、不需要人主观打分。按照这种方法，每个单位都可以与其它单位、自己以往进行客观地比较，有效衡量本单位无人运维（或智能运维）在行业内的相对水平及自身进展。 一、 无人运维评级 希望能够量化、综合评估运维的生产力。因此，在设计具体指标的时候，我们考虑了如下因素： 1）直观上来讲，为了达到同等的稳定性、可靠性SLA，如果依赖人力的决策越多，其无人运维评级水平就相对低一些 2）希望这个评估指标能够与以下因素脱钩：行业、业务类型、业务规模、架构、技术、加班程度、外包情况等等 3）运维人力计入负责运维服务器、存储、网络、中间件、数据库、应用的所有人力 4）运维人力计入人力查看监控数据、排除故障、运维规划，盯屏幕、值班闲置的事件，但是不计入运维人员用于开发运维工具的时间 可以利用这种评级方法对同一行业的不同机构、不同行业的机构之间进行进行横向的量化比较，也可以对同一家机构不同时期进行纵向的量化比较。 CPO和无人运维评级可以给大家提供一个量化的依据，大家可以看到自己处于什么水准，同行处于什么水准，促进大家更好地朝着最终的无人运维目标前进。 二、通过AIOps实现无人运维 无人运维是我们的终极目标，AIOps是我们通往这个目标的手段。 AIOps的组成部分： 左侧是监控系统，相当于“眼睛”，采集各类运维监控数据（抓包、埋点、拨测、日志、流程等）， 全面感知系统状态； 中间部分是“大脑”，就是AIOps，它以眼睛感知到的数据作为输入，做出实时的运维决策，从而驱动“手”执行一些自动化的操作。此外，大脑还负责把监测的历史数据梳理成高水平的知识（即运维知识图谱），从而可以被算法模块调用、同时也可以供人查询 右边相当于“手”， 是基于确定逻辑的自动化工具，负责一些比如重启、回滚、流量调度、扩缩容、跨机房迁移等操作； AIOps运维大脑主要包含两大部分： 1.运维知识图谱 定义：线下挖掘运维历史数据、建立各种画像，梳理出各类高水平的知识 这些知识有两类基本用途： (1)可以通过查询工具（比如人机对话机器人）被运维人员消费 (2)动态决策利用实时监控数据和已经挖掘好的运维知识图谱进行实时决策 2.动态决策 定义：包括故障发现、故障定位、故障处置、故障规避等大场景 （1）故障发现包含单指标异常检测、多指标异常检测、文本日志异常检测、交易链条日常检测等等 AIOps要解决的是“系统+算法”问题，而不是简单的算法问题。这是因为我们的运维对象是个庞大、复杂、跨协议层的系统，它里面的大量逻辑是程序员写的代码和各种网络协议和应用协议。因此，AIOps运维大脑中的每一个模块都相当复杂，所以我们不要期望把运维数据灌进一个通用AI算法就能完成该模块的功能。 解决任何一个AIOps中的模块或场景，都需要有“AIOps架构师”把复杂的场景和需求拆解成具体的功能模块： “眼”、“手”、“脑”。 “眼”解决那些通过采集数据全面感知系统运行状态就能解决的问题 “手”解决那些基于固定逻辑就能解决的问题； “脑”又细分为两类模块： （1）通过挖掘历史数据总结出来各种画像和知识； （2）通过动态决策算法来处理各种具体运维场景。 “脑”里面的两个模块必须能被当前AI技术所解决（要求数据丰富、信息完整、清楚定义、单领域） 运维领域有很多问题当前AI技术没有办法直接整体解决，在这种情况下我们就继续把该问题拆解成更细的模块以期能够被当前AI技术解决 AIOps运维大脑的各个模块采用的通用AI算法差异非常大，有些模块还需要若干通用AI算法的组合才能良好解决 三、 智能故障发现 智能故障发现包括故障发现和故障定位 单指标异常检测的最新进展： 1）我们IMC2015工作是有监督的异常检测，解决了之前朴素异常检测算法无法普适的问题 2）后来我们在推广这个技术的过程中，发现有监督异常检测算法的应用场景是有限的，所以后来我们在WWW2018发明了一种无监督的异常检测算法 3）随着在实践中对该WWW2018算法的使用，发现它也存在一些不足。比如，当存在违反周期性的异常时，使用该算法效果不好，因此我们加入了时间信息解决了这个问题 4）WWW2018算法在处理非高斯噪声的指标时也存在不足，我们就实现了一个基于对抗生成网络的算法把这个问题解决了 5）此外，我们通过聚类算法和迁移学习，实现了对于百万级指标进行异常检测 6）对于游戏等生命周期很短的应用通过半监督学习快速进行异常检测 7）通过参数自动迁移，在指标模式漂移后自动适配异常检测算法。最后这些算法整合成了我们非常智能的单指标异常检测算法 在单指标异常检测的基础上，我们还实现了多指标异常检测、面向文本日志的异常检测、对交易链条的异常检测、异常机器定位、异常多维定位、变更故障定位、交易链条定位等。这些AIOps最终被整合在一起，形成我们的“智能故障发现”系统。 智能故障发现系统：一线运维人员无需关注背后的种种算法：当有故障发生时，系统直接告诉运维人员哪里出了什么样的故障，以及该故障的原因是什么。系统不是将海量的监控都推给运维人员让他自己搞清楚问题是什么，而是已经汇总好，直接给出问题所在。 例如：某一个具体日志时间，发生故障时第三个参数取值的分布在故障之前和故障之后有显著变化，这样就给运维人员提供了非常清晰的提示和参考，指导人员下一步该怎么做。同时系统还会提示本次故障和历史上某次故障症状上非常相似或有某种关系，进而建议运维人员现在可采取什么样的处置方案应对当前故障。 四、运维知识图谱 构建运维知识图谱是指从运维数据中自动挖掘： 1.各类运维主体 2.运维主体的各类特性画像和规律 3.运维主体之间的关系 运维主体包括系统软件、硬件及其运行状态 软件是指服务、微服务、中间件、存储服务、数据库等等； 硬件是指机房、机群、机架、服务器、虚拟机、容器、硬盘、路由器、交换机等等； 各类监控数据，包括指标、日志事件、Trace、变更、流程等等。 运维知识图谱与传统的运维专家知识又有什么区别呢？ 第一，知识图谱是中心化的，而传统专家知识是分布在运维专家头脑中的，是去中心化的。 第二，知识图谱是连在一起的“一幅大图”；而专家知识是割裂的，所以，想要实时地把分布在专家头脑中的知识以及静态CMDB数据关联在一起，解决实时问题显然是不可行的。 第三，知识图谱可被快速查询，专家知识需要人力关联，所以缓慢易错。 第四，知识图谱可自动更新，而专家知识需要手动更新。 第五，可以自动生成知识图谱的变化报表，而利用专家知识要靠手动撰写报告。因此，建立运维知识图谱的优势是非常明显的。 运维知识图谱与CMDB的区别是什么呢？ 运维知识图谱包含基于人工智能的、模糊的、自动化挖掘的知识，而CMDB是确定的、手工配置的知识或基于确定逻辑自动配置的知识。 五.智能运维的发展历程 在运维发展的过程中，最早出现的是手工运维，在大量的自动化脚本产生后，就有了自动化的运维，后来又出现了DevOps和智能运维 在运维的过程中，涉及到的步骤可以概括为：产生海量的监测日志，进行分析决策，并通过自动化的脚本进行控制 运维的发展过程，主要是分析决策步骤发生了变化：起初，由人工决策分析；后来，在采集数据的基础上，使用自动化的脚本进行决策分析；最后，用机器学习方法做决策分析 很多故障都是突发的，在处理突发故障时，我们主要关心三个问题：发生了什么，怎么解决，多长时间能解决。由人力来回答这些问题效率低、不准确、不及时。因为我们要对付的这个系统实在是太复杂了。AIOps提高运维生产力的一种方式就是把处理突发故障时的人力分析尽可能的都替换成机器来做。 我们现在有非常多的监控工具，采集存储了海量的、价值极高的各种监控数据。我们希望当遇到突发事件的时候，能够基于这些数据快速准确做出决策。而处理海量、高速、多样的数据并产生高价值，正是机器学习的专长。也就是说，采用机器学习技术是运维的一个必然的走向。 1、智能运维科研门槛高 智能运维需要三方面的知识： 第一，我们要熟悉应用的行业，比如说互联网、电信或者相对传统的行业，如金融、电力等等。第二，我们要熟悉运维相关的场景，包括异常检测、故障预测、瓶颈分析、容量预测等。第三，虽然工业界熟悉运维行业和场景，熟悉生产实践中的挑战，也有数据。但是，工业界并不熟悉整个智能运维中最重要的部分——如何把实际问题转化为算法问题（后面会讲到如何把实践中的难题分解成多个算法并逐个解决）。同时，工业界也不太熟悉查阅科研文献，特别是跨行业的文献。因此，智能运维是一个需要三方面领域知识结合的高门槛领域。 2.AIOps拥有广泛的AI算法，要具体问题具体分析 AIOps领域的算法种类多种多样,不同的场景下使用的人工智能方法也有所不同。只有针对具体问题进行具体分析，足够聚焦，才有可能通过人工智能的方式解决问题。 3.尽量减少数据标注 运维领域算法如果能不用数据标注就尽量不用数据标注，这一点与计算机视觉领域有强烈的对比。比如，在计算机视觉领域，物理识别应用要求有数据标注，对标注质量要求也比较高，在没有标注的情况下可以通过众包解决。通常，一个普通人就能完成标注，质量也能有保证。不同的是，运维领域的数据标注无法通过众包来解决，因为只有运维领域专家才能有效、准确地进行标注。然而，运维领域专家因工作忙碌抽不出时间，也不愿意进行标注。 因此，我们做智能运维算法时，首选能使用无监督方法就使用无监督方法，在无监督方法效果不理想时，再加入主动学习，让人工对效果不理想的部分做进一步反馈，用于指导、调整无监督算法里面的参数；其次，使用半监督学习方法，比如有监督学习+迁移学习、无监督学习+迁移学习等；最后，使用有监督学习方法，不过由于标注很少且很难获得标注，整体效果并不好。 4.尽可能使用多模态数据 解决真实事件问题，不能只看指标、日志或者调用链，而是尽量使用多模态数据，因为数据特征越丰富，智能运维的结果就会越明显。在这个过程中，需要根据“知识+数据”双轮驱动中的“知识”对多模态数据进行有效关联，实现“上帝视角”，避免“盲人摸象”的效果。这里说的“知识”可能来自一部分数据，比如拓扑、调用链；也可能来自于经验，基于IT 架构挖掘出来的因果关系。 5.智能运维将来的愿景 现有监控提供数据采集，AIOps的引擎做出决策建议，少数运维专家最终决策，执行自动化脚本进行故障止损、修复、规避等操作 具体而言，AIOps引擎 中的“异常检测”模块在检测到异常之后可以将报警第一时间报给运维人员，达到“故障发现”的效果；“异常定位”模块达到“故障止损”的效果，它会给出一些止损的建议，运维专家看到这个定位之后也许他不知道根因，但是他知道怎么去根据已有的预案来进行止损，然后再执行自动化的脚本。 如果是软件上线导致的问题我们回卷，如果业务不允许回卷就赶紧发布更新版本；如果是容量不够了，那我们动态扩容；如果部分软硬件出问题了，我们切换一下流量等等。AIOps引擎中的“根因分析”模块会找出故障的根因，从而对其进行修复。 如果根因是硬件出了问题，像慢性病一样的问题，那我们可以让我们的运维人员去修复。同时，AIOps 引擎中的“异常预测模块”能够提前预测性能瓶颈、容量不足、故障等，从而实现“故障规避”。比如，如果我们预测出来了设备故障的话，那么可以更新设备；如果说我们发现性能上的瓶颈是代码导致的，那就交给研发人员去修改。 上图是展望的AIOps大概的体系结构 核心的AIOps的引擎会积累一个知识库，从里边不断的学习。也就是说监控数据会给AIOps提供训练数据的基础，然后专家会反馈一部分专家知识。这里面关键的一点是，我们还是离不开运维专家的。最终的止损、规避的决策、软件的代码修复以及设备的更换还是要靠人来做的，但是机器把绝大部分工作都做了，包括异常检测、异常定位、根因分析、异常预测。","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"智能运维","slug":"智能运维","permalink":"https://hemiaomiao.github.io/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/"}],"author":"Miaomiao"},{"title":"win10系统修改host文件的方法","slug":"win10系统修改host文件的方法","date":"2021-10-28T08:32:59.000Z","updated":"2021-10-28T09:05:18.601Z","comments":true,"path":"2021/10/28/win10系统修改host文件的方法/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/28/win10%E7%B3%BB%E7%BB%9F%E4%BF%AE%E6%94%B9host%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"win10系统修改host文件右键是没有以管理员权限打开的功能，所以要用别的方法修改host文件1.进入host文件的目录快捷键Windows+R，输入c:\\windows\\system32\\drivers\\etc 2.选择host文件，右击，选择“属性”，然后选择“安全” 3.点击“编辑” 4.点击“添加” 5.点击“高级” 6.点击“立即查找” 7.在“搜索结果”里面选择当前Windows的登录账号 8.点击“确定”，会发现选中的用户会出现在文本框里 9.点击“确定” 10.会发现你的账户添加到了组中，选中当前的Windows账号，勾选“完全控制”和“修改”的权限 11.点击右下角的“应用” 12.系统会弹出提示框，选择“是” 13.点击“确定” 14.用记事本打开host文件，修改后就可以保存了","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"Miaomiao"},{"title":"makedown安装教程","slug":"makedown安装教程","date":"2021-10-28T04:24:46.000Z","updated":"2021-10-28T08:30:47.256Z","comments":true,"path":"2021/10/28/makedown安装教程/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/28/makedown%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"1.下载makedown安装包，并安装 点击该程序，一路next就可以了 2.输入激活的密钥entry key:激活邮箱：Soar360@live.com授权密钥：GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 3.解决无法渲染HTML win10系统安装makedown会出现这个问题，需要安装组件Awesomium1.6.6SDK，安装的时候选择Typical 4.把英文切换成中文Tool &gt; Options &gt; Language 中选择“中文(中国)”，重启即可使用 5.修改字体大小工具-&gt; 选项 -&gt; 编辑器 -&gt; 字体（16,个人感觉显示视觉效果好） 工具 -&gt; 选项 -&gt; 样式表 -&gt; solarized-dark.css","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"markDown","slug":"markDown","permalink":"https://hemiaomiao.github.io/tags/markDown/"}],"author":"Miaomiao"},{"title":"综述论文的写作方法","slug":"综述论文的写作方法","date":"2021-10-14T05:46:08.000Z","updated":"2021-10-14T13:31:20.000Z","comments":true,"path":"2021/10/14/综述论文的写作方法/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/14/%E7%BB%BC%E8%BF%B0%E8%AE%BA%E6%96%87%E7%9A%84%E5%86%99%E4%BD%9C%E6%96%B9%E6%B3%95/","excerpt":"","text":"关键词： 3-8个左右 摘要： 300字左右，使用第三人称和过去式 介绍综述的内容 引言： 中文：300字以内 英文：3段 课题的研究背景和意义 课题相关的概念和定义 课题的作用 / 优点 研究现状和存在的问题 综述的内容 结语：200字以内 归纳总结，高度概括综述的内容 简明扼要地指出目前研究中待解决的问题 课题的意义和价值 给出自己的观点意见 （可以没有） 指出未来的发展趋势","categories":[{"name":"科研","slug":"科研","permalink":"https://hemiaomiao.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://hemiaomiao.github.io/tags/%E8%AE%BA%E6%96%87/"}],"author":"Miaomiao"},{"title":"机载网络已读的论文总结","slug":"机载网络的论文总结","date":"2021-10-11T11:36:49.000Z","updated":"2021-10-18T12:57:12.000Z","comments":true,"path":"2021/10/11/机载网络的论文总结/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/11/%E6%9C%BA%E8%BD%BD%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/","excerpt":"","text":"2021.10.14 论文传送门1： 机载网络技术综述_2008年 2021/10.16 论文传送门2：机载网络体系结构及其协议栈研究进展_2016年 2021/10.17 论文传送门3：民用飞机网络安全问题与策略探究 论文传送门4：民用飞机机载网络安保设计方法研究 论文传送门5:飞机机载网络安保规划流程探讨","categories":[{"name":"科研","slug":"科研","permalink":"https://hemiaomiao.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://hemiaomiao.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"机载网络","slug":"机载网络","permalink":"https://hemiaomiao.github.io/tags/%E6%9C%BA%E8%BD%BD%E7%BD%91%E7%BB%9C/"}],"author":"Miaomiao"},{"title":"论文阅读方法","slug":"论文阅读方法","date":"2021-10-11T11:27:18.000Z","updated":"2021-10-28T11:29:39.748Z","comments":true,"path":"2021/10/11/论文阅读方法/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/11/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/","excerpt":"","text":"","categories":[{"name":"科研","slug":"科研","permalink":"https://hemiaomiao.github.io/categories/%E7%A7%91%E7%A0%94/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://hemiaomiao.github.io/tags/%E8%AE%BA%E6%96%87/"}],"author":"Miaomiao"},{"title":"机器学习基础知识","slug":"机器学习","date":"2021-10-09T10:59:41.000Z","updated":"2022-03-02T01:58:27.333Z","comments":true,"path":"2021/10/09/机器学习/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://hemiaomiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"author":"Miaomiao"},{"title":"英语六级","slug":"英语六级","date":"2021-10-04T10:18:09.000Z","updated":"2021-12-22T09:14:29.106Z","comments":true,"path":"2021/10/04/英语六级/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/04/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7/","excerpt":"","text":"要带的东西准考证、身份证、一卡通、耳机、2B涂卡笔、橡皮、0.5mm的黑笔 做题顺序仔细阅读 、 搭配题 、 翻译 、 完形填空 （没有时间就全蒙B） 一.听力1.听力的解题思路(1) 划出选项的关键词 注意： 选项中重复的内容不要划 划出选项中的： 名词 形容词 副词 独特的动词 比较级 / 最高级 数字、否定词（ 如less ）、专有名词 例如： (2) 划关键词的时间： 试音的时候、读direction的时间、读question的时间 注意： 在direction和最后一个question读完之前，赶紧回头看接下来的题目中选项的关键词，先看前2题的关键词，前2题结束了，看下一题的关键词 (3) 方法 听力内容是按题目的顺序来的，当前面选项没有听到，但是已经在读后面的题目的时候，前面的题目直接蒙了，不要纠结 盯着划的关键词，跟着听力后面默读，听力说一句自己跟着说一句，这样可以集中注意力 把选项里面听到的内容划出来，听到什么选什么，当一道题有多个选项的内容都被读到的时候，选择被读到的关键词个数更多的选项，也就是被读到的内容更多的选项 第一部分男女对话的题目，在听到的选项上面标注一下是男的说的还是女的说的，然后听一下题目是问的男生还是女生，其它题目全部不要听题目，听到哪个选项读到的内容更多就选哪个 听力报问题的时候，涂卡，听力一放完会立马收答题卡 (4) 听力蒙题技巧 （每个部分有题目没有听到选项的时候，按照这个蒙） 1 —— 4 A （没有听到的题目全选A）5 —— 8 B9 —— 11 A12 —— 15 A16 —— 18 D19 —— 21 A22 —— 25 B 2.精听的步骤 （备考期间）针对六级的方法： (1) 整篇泛听 整篇听一遍，尽量掌握文章大意，听的过程中不能看原文 (2) 逐句精听** 用App里面的单句精听模式，播放一句，听一句，听懂了就直接听下一句，没有听懂，不要看原文，再反复听3-5遍 3-5遍听懂了 —— 跟读一遍 3-5遍没有听懂 —— 看原文 (3) 再听一遍全文** 如果还是有的句子听不懂，不看原文，再反复听3-5遍，直到最后能听懂整篇材料 在习惯了常速播放的听力之后，用1.2倍速播放 (4) 分析听不懂的原因 单词不认识——扩充词汇量 单词发音不准确——重听/词典（英美都听） 连读没听出来——跟读模仿，看一些发音规则的课程 长难句无法理解——感受语调轻重，剖析主干 (5) 跟读训练 播放一句，重复一句，特别是没听懂过的地方 在习惯了常速播放的听力之后，用1.2倍速播放 二.仔细阅读阅读1.做阅读的方法(1) 每篇阅读先读前2题的题目，因为一次性记不住四道题的题目，然后去文章中定位句子，当有题目找不到在文章哪里的时候，看下一题的题目在文章中的定位句子在哪里，那么前一道题目就在这之前的段落找出处，因为题目顺序和段落顺序一致 (2) 定位的句子一般就一句话（ .表示一句话结束 ），最多两句话 (3)看选项的内容有没有在定位的句子里面提到 提到是指：选项出现了定位的句子里面的原词 或者 和定位的句子意思差不多，是同义改写 (4) 如果选项的内容在定位的句子里面出现了原词，那要看该选项剩下的部分在原文中有没有提到，或者是不是和原文的意思相反，干扰选项一般都是增加定位的句子里面没有提到的单词，属于无中生有 (5) 如果选项的内容在定位的句子里面没有出现原词，此时分成两种情况： 选项出现了文章中别的句子里面的原词（别的句子是指： 定位的句子以外的句子），直接排除该选项，属于内容拼凑 选项的内容是定位的句子里面没有提到的意思，直接排除 选项的内容是对定位的句子里面一些词进行了意思上的同义改写，则是正确选项 (6) 正确选项都是对定位的句子进行同义改写 同义改写是指用不同的单词表达了相同的意思 (7) 错误选项都是无中生有或者 或者 和原文意思相反 “无中生有” 指的是： 选项中一部分是定位的句子里面的原词，但是剩下的部分出现了定位的句子里面没有提到的内容 选项的内容根本没有在定位的句子里面提到 2.阅读的技巧(1) 选项是3,3,2,2的形式，例如 3个A + 3个C + 2个B + 2个D (2) 阅读题不会出现3个连着的题目都选同一个选项，例如 B、B、B 三.搭配题1.做搭配题的方法(1) 先把所有题目的关键词划出来，关键词有形容词，名词，动词等，和其他题目一样的单词不要划 (2) 然后读所有的题目，理解题目的意思，再看一下所有题目划出来的关键词 (3) 接着去文章找关键词以及和题目意思相似的段落 (4) 把已经匹配的段落划掉，一直没有找到匹配段落的题目直接跳过，看下一道题，再剩下的段落中不断缩小范围 (5) 只要段落中出现和题目的三个关键词意思一样，或者段落的意思和题目的意思大致相同，就是正确答案 四.作文(1)六级作文的类型1.议论文 —— 现象解释 为什么要，分析原因，分析这个东西是什么，分析它的重要性 关键词： what 、 why 、 importance living in the virtual world. Try to imagine what will happen when people spend more and more time in the virtual world instead of interacting in the real world. the importance of building trust between employers and employers. the importance of mutual understanding and respect in interpersona relationships the imporlance of having a sense of community responsiliy. the importance of innovation and measures to be taken to encourage innovation/creation/invention. 2.议论文 —— 观点选择 两个东西二选一，是否要做一件事 关键词： whether 、 choice 、 option whether to major in science or humanities at college 3.议论文 —— 问题解决 / 措施 该如何去做一件事情 关键词： how to 、 measures how to balance job responsibilities and personal interests. the importance of innovation and measures to be taken to encourage innovation / creation/invention. 4.谚语 关键词： saying 、remark commenting on the saying “Respect others, and you will be respected.” 5.图表 (2)六级作文模板第一段： 1.议论文 Living in an era of information , … has / have become increasingly crucial (重要的) / universal (普遍的). I , as a youngster , deem that it is necessary (现象解释/措施类) / beneficial (观点选择) for sb to do sth.There are a host of reasons to account for my viewpoint. 生活在一个信息时代，…变得越来越 重要 / 普遍。我，作为一个年轻人，认为它是重要的 / 有利的 对某人来说去做某事。有很多理由来支持我的观点。 2.谚语 This is a simple but enlightening saying —— “…（把题目的谚语抄一下)” .The profound meaning lying in this saying tells us that … is theengine which drives both our study and further career (话题范围词可以替换). 这是一个简单但是令人 启发的谚语——“谚语的内容”。在这个谚语里面深刻的含义告诉我们…是发动机驱使我们的学习和未来的职业。 3.图表 This is a simple but enlightening picture (图片) / chart (图表) , where …（描述图片的内容）.The profound meaning lying in this picture / chart tells us that …（图片内涵) . There are a host of reasons to account for this phenomenon. 这是一个简单但是令人启发的 图片 / 图表，….。在这个图片 / 图表里面的深刻的含义告诉我们…。有很多理由来支持我的观点。 第二段 First and foremost , supposing that sb / sth intend(s) to acquire and enjoy long-time happiness / success / prosperity(繁荣，描写社会或者政府) , it is reasonable (正面的) / not reasonable (负面的) for sb / sth to do sth. No one can deny that sth lay(s) a solid foundation for future / academic success. In addition , without a doubt , sth is the stepping stone which can enrich our horizons , enhance our comprehensive abilities , ensure more fruitful results , and enable us / society to go further on the way of personal development (描写人) / prosperity. Last but not least , without sth (正面的) / with sth (负面的) , sb are prone to confine themselves to narrow——mindedness and poor abilities. Provided that sth (话题范围词) can be compared to building the skyscraper ，sth will make the building taller and firmer. 首先，假如某人想要获得和享受长期的 快乐 / 成功 / 繁荣，它是 合理的 / 不合理的 对于某人来说去做某事。没有人能否认某事为 未来 / 学业成功 奠定了一个坚实的基础。除此之外，毫无疑问，某事是垫脚石，能丰富我们的视野，提高我们的综合能力，确保更丰富的结果，并且使 我们 / 社会 在 个人发展 / 繁荣 的道路上更进一步。最后，没有某事 / 有某事 ，某人是倾向于限制它们自己在狭隘的思想和差的能力。假如某事能被比作建造一个摩天大楼，某事将使这个建筑更高和更坚固。 第三段 In conclusion , sth is essential (现象解释/措施类) / a better choice (观点选择) for sb/sth. Only when we spare no efforts to do sth , can we have a hopeful and rosy future. 总而言之，某事是 必要的 / 一个更换的选择 对于某人来说。仅仅当我们不遗余力做某事，我们能拥有一个有希望和美好的未来。 作文记忆方法：首先，假如获得和享受长期的快乐，奠定坚实的基础。除此之前，毫无疑问，垫脚石丰富视野。最后，没有某事，倾向于限制，比作建造摩天大楼。 话题范围词：study / education / future career / work / life / society / social development / environment sb 可以是：people / youngsters 年轻人 / teenagers 青少年 / college students 大学生/ senior people 老年人 / freshman 新生 / citizens 公民 / residents 居民 / staff 员工 / parents 父母 / employees 员工 / governments 政府 / society 社会 / children 孩子 / workers 工人 / passengers 乘客 写措施的功能句： … is the engine which drives both our study and further career. Therefore sb should be educated to think critically to cultivate their innovative awareness / independent thinking ability / independent judgement / comprehensive abilities. (…是发动机驱使我们的学习和未来职业。因此某人应该教育去批判地思考来培养他们的 创新意识 / 独立思考能力 / 独立的判断力 / 综合能力。) 描述图表的句子: … increased / reduced from 数字 in 年份 to 数字 in 年份. 一些连词：indeed 事实上 / to be specific 具体而言 / moreover 而且 / as a matter of fact 事实上 / what’s more 而且 / To begin with 首先 / they 、 their(他们的) 、 them （动词或者介词后面） we 、 our（我们的） 、 us（动词或者介词后面） bring us great convenience 给我们带来巨大便利 give priority to sth 优先考虑某事 more and more 的同义替换： a growing number of + 可数名词复数 (越来越多的…) / increasingly + 形容词 (越来越…) many 的同义替换：a host of + 可数名词复数 / a large number of + 可数名词复数 get 的同义替换： acquire / attain / obtain if 的同义替换： supposing that / provided that keep 的同义替换： maintain different 的同义替换: various + 可数名词复数 have 的同义替换： own popular 的同义替换： prevalent 流行的 think 的同义替换： deem that / am convinced that important 的同义替换: crucial / essential / significant good 的同义替换：wonderful very 的同义替换：extremely / greatly common 的同义替换：universal / widespread want 的同义替换： intend to beautiful 的同义替换：attractive improve 的同义替换：enhance / promote finish 的同义替换：accomplish / complete big 的同义替换：vast / large / enormous / tremendous about 的同义替换：above / approximately 大约 much 的同义替换：a great deal of + 不可数名词 be supposed to do sth 应该做某事 spend time in sth / doing sth 花时间在某事 / 做某事 stop doing sth 停止做某事 need to do sth 需要做某事 have difficulty in doing sth help sb do sth 常用单词： engine 发动机 prosperity n. 繁荣 prosperous adj. 繁荣的 virtue 美德 curious adj. 好奇的 curiosity n. 好奇心 motivation 动力 responsibility 责任 social responsibility 社会责任感 innovative minds 创新思维 technology 科技 convenient adj. 便利的 convenience n. 便利 enthusiasm 激情 passion 激情 environment n. 环境 environmental adj. 环境的 educational adj. 教育的 education n. 教育 realize 意识到 irrational 不合理的 independent adj. 独立的 independence n. 独立 independently adv. 独立地 judgement 判断力 attain knowledge 获得知识 adequate 充足的 opportunity 机会 develop v. 发展 development n. 发展 their sth 他们的… innovation 创新 skill(s) 技能 communication skills 交流技能 courage 勇气 confidence 自信 control 控制 explore 探索 exploration 探索 academic success 学业成功 the ability to meet challenges 迎接挑战的能力 the ability to solve problems 解决问题的能力 respect v. n. 尊重 serious 严重的，认真的 complex adj. 复杂的 complicated adj. 复杂的 attitude 态度 achieve v. 实现 achievement v. 成就，实现 innovation n. 创新 innovative adj. 创新的 balance v.平衡 balanced adj. 平衡的 interest(s） 兴趣 choose 选择 culture 文化 interesting 有趣的 elegant 优雅的 Internet 互联网 activity (activities) 活动 take part in activities 参加活动 learning resources 学习资源 atmosphere 气氛 efficiency n. 效率 efficient adj. 有效率的 working efficiency 工作效率 learning efficiency 学习效率 interpersonal relationship 人际关系 understand 理解 sympathy 同情 sense n. 感觉 difficult adj. 困难的 difficulty n. 困难 success n. 成功 successful adj. 成功的 admit 承认 reality 现实 important adj. 重要的 importance n. 重要性 main 主要的 occur 发生 problem 问题 issue 问题 obvious 明显的 apparent 明显的 reveal 显示 appreciate 感谢 neglect 忽视 ignore 忽视 intelligent 聪明的 make us stronger 使我们更强壮 五.翻译1.知识点(1) …之一 ： one of the + 名词复数 (2) 越来越多的： a growing number of + 名词复数 (3) 越来越： increasingly + 形容词 (4) 也 1.also + 谓语动词 2.句尾 + too (5) as 作为 / with 随着 / since 自从，由于 + 句子 (6) 没有主语 1.换成被动 be done 2.用there be 句式 (7) 坐落于 / 位于 be located + 介词 （ in / at / on / along 沿着 ） 注：north 北方 / east 东方 / south 南方 / west 西方 (8) 以…而闻名 be famous for (9) 追溯到 be traced back to (10) 来源于 originate from (11) …以来 / 过去…年里 for + 时间段 注： 句子要用现在完成时 has / have + done (12) 句子有”了” ，要用现在完成时 (13) 具体到某一天要用介词on on + 月份 + 天，+ 年份 2.翻译的时态(1) 一般现在时 (2) 现在完成时 (3) 一般过去时 3.翻译的方法(1) 调整短句内的语序 短句是两个逗号之间的句子 把中文意思调整到自己能看懂，只要和原文意思相近就可以 调整后的语序尽量保持 主谓宾 / 主系表，把 “…的” 改为 “…有” 短句的主语保持一致 (2) 先翻译主干 (主谓宾 / 主系表)，再翻译修饰部分 修饰部分的翻译技巧： 1.修饰后置 把表示 时间 和 地点 的状语往后放 把表示 “…的” 的定语往后放，如果修饰部分较长或者修饰部分有动词，用定语从句。如果是单个的形容词，用 adj + n 的形式，还可以使用 A of B 的形式表达 “B的A” 定语从句的引导词有 which / who / when / where / whose 定语从句较短，不加逗号，定语从句较长，加逗号 (3) 动词 1.动词的地位相同，用 and 来表示并列关系，V1 , V2 ,…, and Vn 2.动词的地位不同，不是并列关系，用 v-ing 或者 which (4) 长难句万能模板 主语 , 同位语 / with 引导的插入语, 谓语 + 宾语 , V-ing + … ，and , which … 同位语的形式是：n + … ， 同位语是对主语进行解释 主语是所有短句的主语 V-ing 引导状语从句 with 引导伴随状语，表示 “随着…” 或者 “有…” and 表示并列关系的动词，and引导的句子可以出现谓语动词 which 引导非限定性定语从句 插入语在主语和谓语动词之间 (5) 检查时态、单复数、三单 英语一个句子里面 although 、though 、but 只能出现一个，因为although引导的句子翻译成 “尽管…，但是…” 注意： 1.一个长难句只能有一个谓语动词，或者用and连接的多个谓语动词 2.所有短句的逻辑主语必须是一致的 3.to do 表示目的 , “来…” 4.遇到不会的单词 (1) 用该单词的同义词或者近义词替代该单词(2) 用该单词的上位词替代该单词(3) 用会的单词解释这个单词(4) 修饰部分有单词实在不会写，就直接跳过不写了 5.所有不会的长难句用简单句写，保证语法正确 3.例子(1) 牡丹(peony)花色艳丽，形象高雅，象征着和平与繁荣，因而在中国被称为“花中之王” 思路：牡丹有艳丽的花色，牡丹有高雅的形象，牡丹象征着和平与繁荣，牡丹因而在中国被称为“花中之王” The peony has bright color.The peony has an elegant appearance.The peony is a symbol of peace and prosperity.So it is called “the king of all flowers” 整合： 主语, 同位语, 谓语 + 宾语, and + 谓语 + 宾语, so… The peony, a symbol of peace and prosperity , has bright color , and owns an elegant appearance, so it is called “the king of all flowers”. 主语 + 谓语 + 宾语, which…. The peony, has bright color and an elegant appearance, which is a symbol of peace and prosperity, so it is called “the king of all flowers”. 主语 + 谓语 + 宾语, V-ing, so…. The peony, is a symbol of peace and prosperity, having bright color and elegant appearance, so it is called “the king of all flowers”. 主语, with伴随状语作插入语, 谓语 + 宾语 The peony, with a beautiful color and elegant shape, is the symbol of peace and prosperity. (2) 不少博物馆还举办在线展览，人们可在网上观赏珍稀展品 A host of museums also hold exhibitions on the Internet, where people can appreciate rare and precious exhibits. (3) 然而，现场观看展品的体验对大多数参观者还是更具吸引力 However, it is attractive for most visitors to appreciate displays on spot. (4) 这些博物馆必须采取措施限制参观人数 These museums must take measures to confine the number of visitors. (5) 中国除了关注高等教育外，还将寻找新的突破以确保教育制度更加公平 Besides pay attention to higher education, China will also seek new breakthrough to ensure a fairer educational system. (6) 教育部还决定改善欠发达地区学生的营养，并为外来务工人员的子女提供在城市接受教育的同等机会 The Ministry of Education also decides to improve the nutrition of students in underdeveloped regions, and provide children of migrant workers with equal opportunities of receiving education in cities. (7) 大型公共图书馆不仅提供种类繁多的参考资料，而且定期举办讲座，展览等活动 主干：图书馆不仅提供参考资料，而且举办活动 libraries offer reference materials, and hold activities 整合： Large public libraries not only offer various reference materials, but also hold activities including / such as lectures and exhibitons regularly. (8) 这一新公布的计划旨在减少四种主要污染源，包括500万辆机动车的尾气排放、周边地区燃煤、来自北方的沙尘暴和本地的建筑灰尘 主干：计划旨在减少污染源 project aims to reduce source of pollution This newly-published project aims to reduce 4 main sources of pollution, including emissions from 5 million motor vehicles, coal burning from surrounding areas, sandstorm from the north and local construction dust. (9) 无论在产品还是商业模式上，中国企业家也在努力争做创新的先锋以适应国内外消费市场不断变化和增长的需求 Whether in products or commercial mode, Chinese entrepreneurs also intend to pioneers of innovation in order to meet the demands of ever-changing and increasing consumer markets at home or abroad. (10) 中国正在努力最佳地利用教育资源，这样农村和欠发达地区将获得更多的支持 China is trying to optimize educational resources, so that the rural and underdeveloped areas will acquire more support. (11) 明朝统治中国276年，被人们描绘成人类历史上治理有序，社会稳定的最伟大的时代之一 主干：明朝统治中国276年 The Ming Dynasty ruled China for 276 years 整合： The Ming Dynasty ruled China for 276 years, which is described as one of the greatest eras in human history, and its government was orderly and the society was stable. (12) 有些方言，特别是北方和南方的方言，差异很大，以至于说不同方言的人常常很难听懂彼此的讲话 主干：有些方言差别很大，以至于人常常很难听懂彼此的讲话 some dialects are so different that it is hard for people to understand each other in most cases. 整合： Some dialects are so different, especially between those in the north and south, that it is rather difficult for people who speak different dialects to understand each other’s talks. (13) 为了在科学技术上尽快赶超世界发达国家，中国近年来大幅度增加了研究开发资金 In order to catch up with and surpass the developed countries in science and technology as soon as possible, China has considerably increased the funding of research and development in recent years. (14) 据说龙舟赛始于洞庭湖东岸，为的是搜寻楚国爱国诗人屈原的遗体 It is said that the dragon Boat competition originated from the east shore of the Dongting Lake in order to seek for the body of Qu Yuan, who is a patriotic poet in the Chu State. (15) 在帮助国际社会于2030年前消除极端贫困过程中，中国正扮演着越来越重要的角色 China is playing an increasingly significant role in the process of helping the international community eliminate extreme poverty by 2030. (16) 深圳是中国广东省一座新开发的城市。在改革开放之前，深圳不过是一个渔村，仅有三万多人 Shen Zhen is a newly developed city in Guangdong Province in China. Before the reform and opening-up, Shen Zhen was just a fishing village with a population of over 30000. (17) 洞庭湖位于湖南省东北部，面积很大，但湖水很浅。洞庭湖是长江的蓄洪池，湖的大小很大程度上取决于季节变化 The Dongting Lake, in the northeast of Hunan Province, covers a large area with shallow depth.The Dongting Lake is a flood basin of the Yangtze River, whose size depends largely on the change of seasons. (18) 很多中国新娘也会选择旗袍作为结婚礼服。一些有影响的人士甚至建议将旗袍作为中国女性的民族服饰 In addition, a host of Chinese brides choose qipao as wedding dresses. Some influential figures even suggest that qipao should be used as the national dress for Chinese women. (19) 自动驾驶汽车无需或仅需少量人为操作，即可感测其周边环境并安全行驶 The autonomous vehicle sense their environment and drive safely, which need no or few operations. (20) 近年来，面对能源需求的不断增长和环境问题的增多，新能源汽车市场已经成为中国增长最快的市场之一 In recent years, with a growing number of energy demands and environmental problems, the new energy vehicle market has become one of the fastest-growing markets in China. (21) 作为现代中国的缩影，上海是一个朝气蓬勃和充满活力的国际大都市 Shanghai, a typical example of contemporary China, is vigorous and energetic international metropolis. (22) 上海是全球金融中心之一，被称为”东方的巴黎” Shanghai is one of the global financial centers, which is called “Paris of the East”. (23) 近年来，中国越来越多的博物馆免费向公众开放 In recent years, a growing number of museums in China have been open to the public free of charge. (24) 博物馆展览次数和参观人数都明显增长 The number of exhibitions and visitors in museums have increased obviously. (25) 虽然上海的文化遗迹无法与北京媲美，但是风格各异的外国建筑为这座城市注入了无限的魅力 Shanghai can not compare with Beijing in cultural relics, but foreign buildings with various styles inject infinite beauty into this city. (26) 漫步在这座现代化的大都市中，人们可以感受到这座城市的活力 Walking in this modern metropolis, people can feel the energy of this city. (27) 众多的摩天大楼反映了上海巨大的发展和史无前例的变化，尤其是新中国成立以后 A host of skyscrapers reflect the great development of Shanghai and unprecedented changes especially after the establishment of new China. (28) 青海湖位于海拔3205米、青海省省会西宁以西100公里处，是中国最大的咸水湖，面积4317平方公里，最深处25.5米，有23条河注入湖中，其中大部分是季节性的 The altitude of Qinghai Lake is 3205 m, located at about 100 km west of Xi’ning, which is the capital of Qinghai Province.It is the largest salt water lake in China, and covers an area of 4317 km^2, whose maximum depth is 25.5 m. 23 rivers run into the lake, most of which are seasonal. (29) 百分之八十的湖水源于五条主要河流 80% of the lake water originates from 5 main rivers. (30) 青海湖位于跨越亚洲的几条候鸟迁徙路线的交叉处 The Qinghai Lake is located at the intersection of several routes by which migrant birds fly across Asia. (31) 许多鸟类把青海湖作为迁徙过程中的暂息地，湖的西侧是著名的”鸟岛”，吸引着来自全世界各地的观鸟者 A host of birds regard the lake as temporary habitat during the process of migration. On the west of the lake is the famous “the island of birds”, which attracts to people who see birds from all over the world. (32) 每年夏天，游客们也来这里观看国际自行车比赛 Every summer, tourists also come here to see the international cycling competition. (33) 唐朝始于618年，终于907年，是中国历史上最灿烂的时期 The Dang dynasty started from 618, and ended in 907, which was the most prosperous period in Chinese history. (34) 经过三百年的发展，唐代中国成为世界上最繁荣的强国，其首都长安是当时世界上最大的都市 By the development of about 300 year, the China became the most prosperous country in the world during the Tang Dynasty. Its capital Chang’an was the largest metropolis in the world at that time. (35) 这一时期，经济发达、商业繁荣、社会秩序稳定、甚至边境也对外开放 During this period, the economy was developed, the business was prosperous, the social order was stable, and even the boundary was open to the world. (36) 随着城市化和财富的增加，艺术和文学也繁荣起来 With the urbanization and the increase of wealth, arts and literature also became prosperous. (37) 李白和杜甫是以作品简洁自然而著称的诗人 Li Bai and Du Fu were poets who were famous for simple and natural works. (38) 他们的诗歌打动了学者和普通人的心 Their poems deeply moved scholars and ordinary people. (39) 即使在今天，他们的许多诗歌仍广为儿童及成人阅读背诵 Even today, a host of poems are still widely read and recited by children and adults. 4.翻译的单词prosperous 繁荣的period 时期extreme adj. 极端的poverty n. 贫穷poor adj. 贫穷的national 国家的，民族的national treasure 国宝such as + 词for example + 句子large-scale 大规模的symbol n. 象征symbolize v. 象征classical 经典的literature n. 文学literary adj. 文学的novel 小说dynasty 朝代rule 规则，统治describe v.描写greatest 最伟大的period 时期steady 稳定的society 社会orderly 有序地governance n. 管理government 政府human 人类history 历史foreign 外国的reader 读者feel 感觉story (stories) 故事vivid 生动的touching 感人的interesting 有趣的rapid 快速的growth n.增长Chinese 中国人，中国的China 中国economy n. 经济economic adj. 经济的improvement n. 提高，改善global 全球的influence n. 影响country (countries) 国家start / begin 开始for thousands of years 千百年来poem 诗歌drawing 图画create v. 创造creation n. 创造praise v. 赞扬ordinary people 普通人family 家庭decoration n. 装饰Spring Festival 春节dialect 方言be considered as 被认为是component 组成部分local 当地的culture 文化widely 广泛地everyday 每天的conversation 对话in recent years 近年来digital 数字的library (libraries) 图书馆appear v. 出现Chinese characters 汉字write 写uniform 统一的way 方式hardly have 几乎没有communication n. 交流communicate v. 交流pollution n. 污染air pollution 空气污染serious 严重的，认真的choose 选择energy 能源new energy 新能源predict 预测it can be predicted that 可以预见constant 不断的constant improvement 不断改善facility (facilities) 设施gym 体育馆keep fit 健身ancient 古老的town 城镇province 省Zhejiang Province 浙江省Yan’an 延安 （当地点的拼音引起歧义的时候，加’）mountain 山capital 首都nearly 几乎，差不多unique 独特的origin 起源museum 博物馆form 形式exhibition 展览on holidays 假期Chines people 中国人store 商店，储存decade 十年various 各种各样的，不同的measure 方法，测量disaster 灾难river 河lake 湖transportation 运输，交通industrial 工业的production n. 生产visitor(s) 游客increase 增加generation 一代hundreds of 上百种altitude 海拔attitude 态度region (s) 地区area 地区greatly 大大地shorten 缩短Tibet 西藏railway 铁路train 火车scenery 风景international 国际的airport 机场square 广场construction n. 建造begin 过去式 begantake 过去分词 takenbuild 过去分词 builtpeak 高峰，顶点compact 紧凑的allow 允许maximum 最大的the number of ….的数量park 公园，停靠directly 直接地center 中心provide 提供gate 大门through 通过design n. 设计ensure 确保takeoff 起飞annual 每年的expect 期待in the word 在世界上market 市场，集市it is recorded 据记载total 总共的million 百万hundred 百thousand 千extremely 极其地dangerous 危险的defense n. 保卫especially 尤其manufacture 制造subway 地铁take the subway 乘地铁house 房子phone 手机reform 改革revolution 改革civilization 文明above adv. 大约largest 最大的spread 传播a unique way of expression 一种特殊的表达方式number of visitors 参观人数constant improvement of facilities 设施的不断完善lakes in many places 在许多地方的湖China in history 历史上的中国in China 在中国population 人口language 语言native 本地的speak 说nowadays 如今，现在expression n. 表达reality 现实advanced 先进的media 媒体virtual 虚拟的represent 代表be the symbol of 是…的代表mean 意味着elegant 优雅的beautiful 美丽的rare 稀有的precious 珍贵的exhibit 展览品appreciate 感谢，欣赏most 大多数，最enter 进入take measures to do sth 采取措施做某事the number of …的数量college 大学vocational 职业的in the next few years 在未来几年underdeveloped 不发达的rural 农村的policy （policies） 政策resource 资源support v. n. 帮助decide v. 决定migrant adj. 移民的nutrition 营养reference n. 参考material n. 材料motor vehicle 机动车emission n. 排放source n. 来源newly-published 新公布的project n. 项目，计划at home or abroad 国内外consumer 消费者consumer markets 消费市场optimize 最优化利用so + 形容词 that 如此…以至于…developed 发达的science 科学technology 科技research 研究funding 资金patriotic 爱国的poet 诗人seek 寻找eliminate 消灭international community 国际社会possess 过程play a significant role 起重要作用village 乡村Yangtze River 长江influential 有影响力的figure 数字，人物advise v. 建议suggest v. 建议few + 可数名词复数little + 不可数名词vehicle 车辆metropolis 大都市free of charge 免费compare to 比喻compare with 比较relic 遗迹inject 注入energy n. 活力seasonal 季节性的cover an area of 占地面积maximum 最大值depth 深度intersection 交叉点Asia 亚洲several 几个route 路线migrant birds 候鸟regard … as 把…看作…temporary 暂时的habitat 栖息地process 过程migration n. 移民attract v. 吸引from all over the world 来自全世界appreciate v. 欣赏tourists 游客competition 比赛wealth n. 财富wealthy adj. 富裕的increase v. n. 增加natural 自然的work v. 工作 n. 作品worker 工人moved v. 打动scholar 学者country 国家countryside 乡村so / thus / therefore 因此traffic 交通tool 工具popular 受欢迎的bike 自行车kingdom 王国king 国王jam n. 堵塞ride bikes 骑自行车","categories":[{"name":"杂项","slug":"杂项","permalink":"https://hemiaomiao.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"英语六级","slug":"英语六级","permalink":"https://hemiaomiao.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7/"}],"author":"Miaomiao"},{"title":"数理统计笔记","slug":"数理统计笔记","date":"2021-10-02T07:10:41.000Z","updated":"2021-10-02T07:10:42.000Z","comments":true,"path":"2021/10/02/数理统计笔记/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/02/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://hemiaomiao.github.io/tags/tag1/"}],"author":"Miaomiao"},{"title":"算法课笔记","slug":"算法课笔记","date":"2021-10-02T07:10:23.000Z","updated":"2021-10-02T07:10:24.000Z","comments":true,"path":"2021/10/02/算法课笔记/","link":"","permalink":"https://hemiaomiao.github.io/2021/10/02/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"https://hemiaomiao.github.io/tags/tag1/"}],"author":"Miaomiao"},{"title":"PDF转word的网址","slug":"PDF转word的网址","date":"2021-09-23T09:20:40.000Z","updated":"2021-09-23T09:36:48.000Z","comments":true,"path":"2021/09/23/PDF转word的网址/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/23/PDF%E8%BD%ACword%E7%9A%84%E7%BD%91%E5%9D%80/","excerpt":"","text":"链接1 ： https://smallpdf.com/cn/pdf-to-word 链接2 ： https://xpdf.net/pdf-to-word","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"Miaomiao"},{"title":"本科毕业设计","slug":"本科毕业设计","date":"2021-09-19T05:17:56.000Z","updated":"2021-10-26T10:25:14.000Z","comments":true,"path":"2021/09/19/本科毕业设计/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/19/%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"基于隐语义模型的新闻推荐系统开发工具：Tomcat 7.0、myEclipse、Android Studio、PyCharm 毕业设计的题目是基于隐语义模型的新闻推荐系统，新闻推荐系统分为三个部分，第一个部分是管理员使用的后台管理子系统，第二个部分是用户使用的新闻客户端APP，第三个部分是新闻推荐子系统。 管理员使用的后台管理子系统是一个web应用，后台管理子系统的功能是管理新闻和管理用户。后台管理子系统使用的是MVC框架。 用户使用的新闻客户端APP是一个安卓应用，新闻客户端的功能是登录、注册、管理个人信息、浏览新闻。浏览的新闻包括两个部分，分别是热门新闻和个性化推荐的新闻。热门新闻是为用户推送浏览量比较高的新闻，个性化推荐的新闻是通过隐语义模型为用户推荐的新闻。 新闻推荐子系统的功能有两个，一个是新闻的采集，另一个是推荐模块。新闻采集的功能是利用python爬虫技术从搜狐新闻的网站爬取新闻。推荐模块的功能是通过隐语义模型为用户推荐新闻，把推荐的结果保存到数据库里面。 隐语义模型的核心思想是通过隐含特征把用户和用户感兴趣的物品联系起来。隐语义模型通过统计用户行为来实现物品的分类，计算出物品在每个类别里面的权重，而不是把物品硬性地分到某个类别。隐语义模型允许指定总共有多少个分类，数字越小，那么分类的粒度越粗。 隐语义模型是用公式：P、Q矩阵相乘来计算用户对物品的兴趣度，P矩阵记录的是所有用户对每个隐类的兴趣度，Q矩阵记录的是所有物品在每个隐类里面的权重。比如说现在有一篇新闻，用户对每个新闻类别的兴趣度 乘以 一篇新闻在每个新闻类别里面的权重就得到了用户对这篇新闻的兴趣度。所有隐语义模型的关键就是得到模型参数P、Q矩阵。 第一步：是构造用来训练的数据集。从数据库里面得到用户的行为记录，把用户浏览过的新闻定义为正样本，推送给用户但是用户没有浏览过的新闻定义为负样本，正样本和负样本的数量要差不多 第二步：是初始化P、Q矩阵。用0到1的随机数去填充P、Q矩阵 第三步：定义损失函数。采用平方损失函数，并且加入正则化项，以防止过拟合 第四步：是使用随机梯度下降算法优化损失函数。随机梯度下降算法是先求损失函数的参数的偏导数，然后沿着最快的下降方向迭代更新参数，直到找到损失函数的极小值，得到最终的P、Q矩阵 第五歩：把P、Q矩阵相乘预测用户对新闻的兴趣度，然后为用户推荐兴趣度最高的TopN个新闻 （用P、Q矩阵去预测用户对新闻的兴趣度的时候，是从数据集里面筛选出用户没有看过的新闻，然后根据当前遍历到的用户确定P矩阵的行，根据当前遍历到的新闻确定Q矩阵的列，然后P矩阵的这一行和Q矩阵的这一列相乘，得到当前用户对当前新闻的兴趣度，然后把新闻id和预测的值保存到List里面） 注： 1.隐语义模型的参数：隐类的个数F（设置为6）、学习速率α（设置为0.02）、正则化参数λ（设置为0.01）、迭代的次数N（设置为5） 2.学习速率α越大，迭代下降的越快，学习速率α和正则化参数λ是通过实验得到的 3.迭代的次数是人为设置的，每次迭代完，都要对学习速率α进行衰减（α=α* 0.9）。因为一开始的时候P、Q矩阵离最优值相差的比较远，所以需要快速下降，当优化到一定程度后，需要对学习速率进行衰减，慢慢的接近最优值 4.梯度下降算法：是沿着梯度下降的方向求解极小值，每次移动一个步长 5.隐语义模型的缺点：不能实时推荐 6.隐语义模型的优点：（1）能够通过设置隐类的个数F控制分类的粒度（2）能确定物品在每个分类里面的权重 7.协同过滤算法分为基于用户的协同过滤算法和基于物品的协同过滤算法。（1）基于用户的协同过滤算法是找到和目标用户兴趣相似的用户，然后把这些用户感兴趣的物品推荐给目标用户。（2）基于物品的协同过滤算法是根据用户行为计算物品之间的相似度，根据物品的相似度和用户的历史行为给用户推荐。协同过滤的缺点是不能很好地处理物品在不同类别里面的权重问题 8.推荐系统的冷启动问题：新注册用户的冷启动问题 解决方法：利用用户注册的时候填写的感兴趣的新闻类别，为用户个性化推荐这些类别下面的新闻 9.损失函数：是用来衡量模型的预测值和真实值之间的差距 10.加入偏置项的隐语义模型增加了用户偏置项和物品偏置项。用户偏置项表示用户的评分习惯和物品本身没有关系的因素。物品偏置项表示物品获得的评分和用户没有关系的因素 把用户行为记录表里面的数据从数据库里面读到csv文件里面：把数据库的用户行为表里面的用户id、新闻id、新闻是否浏览的标识读取出来，并且保存到csv文件里面，csv文件的列名是UserID , NewsID , Bview 训练的数据集就是这个csv文件里面的数据 根据训练的数据集初始化隐语义模型，涉及到的参数是：F: 隐特征（隐类）的数量，设置为6 N: 迭代次数，设置为5 α: 随机梯度下降的学习速率，设置为0.02 λ: 正则化参数，设置为0.01LFM的实现步骤： 1.对P、Q矩阵进行初始化，用随机数填充P、Q矩阵 P矩阵的行的数量是用户id个数，列的数量是隐类F的数量，值是6，矩阵填的值是从0到1的随机数（生成len(userID)行F列从0到1的随机数） Q矩阵的行的数量是隐特征的个数F，值是6，列的数量是新闻id个数，矩阵填的值是从0到1的随机数 2.建立用户-物品对应关系，初始化目标用户样本数据 根据训练的数据里面的bview=1还是0得到每个用户浏览过的新闻和推荐给用户但是用户没有浏览过的新闻，把用户浏览过的新闻记为正反馈1，推荐给用户但是用户没有浏览过的新闻记为负反馈0，获得了记录所有用户正负反馈的新闻列表 3.计算误差 循环上一步得到的记录了用户正负反馈的样本数据，可以知道当前用户对当前物品的偏好值，利用最开始用随机数填充的P、Q矩阵去预测当前用户对当前物品的兴趣度,拿当前用户对当前物品的实际偏好值减去P、Q矩阵预测的结果得到误差 注： 拿P矩阵里面当前这个用户对每个隐类的值，Q矩阵里面当前这个物品在每个隐类里面的值，一行和一列相乘，值的结果就是预测当前用户对当前这个物品的兴趣度 4、循环F个隐类，使用梯度下降算法,优化P、Q矩阵。 梯度下降算法：用到的参数 学习速率α 正则化参数λ 每次迭代完，都要降低学习速率α。一开始的时候由于P、Q矩阵离最优值相差比较远，所以需要快速下降； 当优化到一定程度后，需要放慢学习速率，慢慢的接近最优值 迭代N次之后，得到最终的P、Q矩阵（N是自己设置的参数） 5、先删除推荐表里面的所有推荐记录，查询用户行为表里面所有的用户id，遍历每个用户，从训练数据里面用户自己没有看过，但是其他人看过的新闻里面，利用优化后的P、Q矩阵根据隐语义模型的计算公式预测用户对物品的兴趣度，然后为用户推荐兴趣度最高的前25条新闻 用户行为表里面包括了个性化推荐的新闻和热点新闻 有个热点新闻表 然后把要推荐的新闻保存到数据库的新闻推荐表里面 个性化新闻和热点新闻被用户点击阅读之后，会修改用户行为表，记录已经浏览 新注册的用户注册成功之后，为该用户推荐的个性化新闻是新闻表news里面浏览量排名前400到425的新闻，把这些推荐的新闻更新到用户行为表里面，浏览量置为0，查询财经、科技、健康等各个板块的热点新闻，给用户看的热点新闻更新到用户行为表里面 从搜狐新闻爬取了6个类别的新闻：历史、娱乐、科技、财经、文化、健康把爬取到的新闻的新闻类别model_id、标题、发布时间、浏览量、正文内容所在的文件地址保存到数据库的新闻表里面，新闻的正文内容保存到txt文件里面 新闻客户端一共有7个模块的新闻，分别是基于隐语义模型推荐给用户的个性化新闻、娱乐类的热点新闻、文化类的热点新闻、科技类的热点新闻、财经类的热点新闻、历史类的热点新闻、健康类的热点新闻。用户进入新闻客户端，看到的是新闻列表，新闻列表展示的每条新闻显示的是文章标题和文章的发布时间，点击新闻列表里面的某个新闻，才能看到新闻正文内容 安卓的功能是在activity里面对控件设置了监听器，当监听器被触发的时候，会调用相应的方法去处理 基于隐语义模型的推荐算法 机器学习之隐语义模型LFM介绍与代码实现（篇六） 《推荐系统实践》笔记","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"隐语义模型","slug":"隐语义模型","permalink":"https://hemiaomiao.github.io/tags/%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B/"},{"name":"推荐系统","slug":"推荐系统","permalink":"https://hemiaomiao.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"}],"author":"Miaomiao"},{"title":"hexo博客添加看板娘","slug":"hexo博客添加看板娘","date":"2021-09-17T15:21:02.000Z","updated":"2021-09-19T05:06:42.000Z","comments":true,"path":"2021/09/17/hexo博客添加看板娘/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/17/hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%9C%8B%E6%9D%BF%E5%A8%98/","excerpt":"","text":"一.安装依赖在博客根目录下输入以下命令安装 live2d 模块 npm install --save hexo-helper-live2d 安装成功之后可以看到博客根目录下的node_modules里面有live2d-widget文件，这是动画的主配置 二.下载模型文件在博客根目录下输入以下命令下载相应的画板娘模型： npm install live2d-widget-model-haruto 模型被下载到了博客根目录下的node_modules文件夹里面 注： 把模型名称 haruto&nbsp;换成你想要的模型名称即可（本人选的看板娘模型是 haruto） live2d看板娘的模型预览如下：live2d-widget-model-epsilon2_1 live2d-widget-model-chitose live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-wanko live2d-widget-model-z16 live2d-widget-model-hibiki live2d-widget-model-hijiki live2d-widget-model-haruto 三.添加live2d看板娘到hexo博客打开博客根目录下的&nbsp;_config.yml文件，添加如下代码： #参数配置 live2d: enable: true scriptFrom: local model: use: live2d-widget-model-shizuku #下载的画板娘模型的名字，根据自己的喜好修改 display: position: left #模型位置 width: 270 #模型宽度 height: 400 #模型高度 mobile: show: false #是否在手机端显示 四.执行hexo g &amp; hexo d即可","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hemiaomiao.github.io/tags/hexo/"}],"author":"Miaomiao"},{"title":"hexo Sakura主题的文章复制功能","slug":"hexo-Sakura主题的文章复制功能","date":"2021-09-17T13:07:03.000Z","updated":"2021-09-17T14:23:38.000Z","comments":true,"path":"2021/09/17/hexo-Sakura主题的文章复制功能/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/17/hexo-Sakura%E4%B8%BB%E9%A2%98%E7%9A%84%E6%96%87%E7%AB%A0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/","excerpt":"","text":"1. 找到 sakura-app.jssakura-app.js 位置： E:\\Blog\\themes\\Sakura\\source\\js 2. 在sakura-app.js里面使用快捷键 Ctrl + F 搜索 setClipboardText，修改代码 修改后的代码如下：function add_copyright () { document.body.addEventListener('copy', function (e) { if (!mashiro_global.is_user_logged_in &amp;&amp; window.getSelection().toString().length &gt; 3) { setClipboardText(e) } }) function setClipboardText (event) { event.preventDefault() var textData = window.getSelection().toString().replace(/\\r\\n/g, '\\n') if (event.clipboardData) { addComment.createButterbar('复制成功！', 1000) event.clipboardData.setData('text', textData) } else if (window.clipboardData) { return window.clipboardData.setData('text', textData) } } }","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hemiaomiao.github.io/tags/hexo/"},{"name":"Sakura主题","slug":"Sakura主题","permalink":"https://hemiaomiao.github.io/tags/Sakura%E4%B8%BB%E9%A2%98/"}],"author":"Miaomiao"},{"title":"hexo Sakura主题设置文章按照top值排序","slug":"hexo-Sakura主题设置文章按照top值排序","date":"2021-09-17T02:25:54.000Z","updated":"2021-09-17T03:14:10.000Z","comments":true,"path":"2021/09/17/hexo-Sakura主题设置文章按照top值排序/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/17/hexo-Sakura%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E6%96%87%E7%AB%A0%E6%8C%89%E7%85%A7top%E5%80%BC%E6%8E%92%E5%BA%8F/","excerpt":"","text":"1. 卸载hexo-generator-index插件hexo站点目录下，输入下面命令卸载默认的排序插件npm uninstall hexo-generator-index --save 2. 安装hexo-generator-index-pin-top插件hexo站点目录下，输入下面命令安装新的排序插件npm install hexo-generator-index-pin-top --save 3. 添加front-matter配置项在需要置顶的文章的Front-matter中加上top: 数值即可实现文章按照top值排序。比如下面这篇文章：title: test date: 2021-09-17 10:25:54 categories: 技术 top: 1 注意： 经过以上三步，博客文章按照top值排序的功能按理说已经可以实现了，但是Sakura主题有一点不同。因为Sakura主题在themes\\sakura\\layout_partial\\文件里面的archive.ejs 和 category-archive.ejs 中设置了按照日期排序，所以还需要修改archive.ejs 和 category-archive.ejs 4. 修改themes\\Sakura\\layout_partial文件里面的 archive.ejs 和 category-archive.ejs （ 仅Sakura主题需要进行第四步 ）原来的archive.ejs:&lt;% if (pagination == 2){ %&gt; &lt;!-- 首页默认取最最新文章集 --&gt; &lt;% page.posts.sort('date', theme.homePageSortType).limit(theme.homeArticleShown).each(function(post, index){ %&gt; &lt;%- partial('_widget/index-items', {index: index, post: post}) %&gt; &lt;% }) %&gt; &lt;% } else { %&gt; &lt;% page.posts.each(function(post, index){ %&gt; &lt;%- partial('_widget/index-items', {index: index, post: post}) %&gt; &lt;% }) %&gt; &lt;% } %&gt; 修改后的archive.ejs：&lt;!-- 两篇文章以上 --&gt; &lt;% if (pagination &gt;= 2){ %&gt; &lt;!-- 置顶文章 --&gt; &lt;% page.posts.each(function(post, index){ %&gt; &lt;% if (post.top){ %&gt; &lt;%- partial('_widget/index-items', {index: index, post: post}) %&gt; &lt;% } %&gt; &lt;% }) %&gt; &lt;!-- 首页默认取最最新文章集 --&gt; &lt;% page.posts.sort('date', theme.homePageSortType).limit(theme.homeArticleShown).each(function(post, index){ %&gt; &lt;!-- 其余文章 --&gt; &lt;% if (!post.top){ %&gt; &lt;%- partial('_widget/index-items', {index: index, post: post}) %&gt; &lt;% } %&gt; &lt;% }) %&gt; &lt;% } else { %&gt; &lt;% page.posts.each(function(post, index){ %&gt; &lt;%- partial('_widget/index-items', {index: index, post: post}) %&gt; &lt;% }) %&gt; &lt;% } %&gt; 原来的category-archive.ejs：&lt;% if (pagination == 2){ %&gt; &lt;!-- 首页默认取最最新文章集 --&gt; &lt;% page.posts.sort('date', theme.homePageSortType).limit(theme.homeArticleShown).each(function(post, index){ %&gt; &lt;%- partial('_widget/category-items', {index: index, post: post}) %&gt; &lt;% }) %&gt; &lt;% } else { %&gt; &lt;% page.posts.each(function(post, index){ %&gt; &lt;%- partial('_widget/category-items', {index: index, post: post}) %&gt; &lt;% }) %&gt; &lt;% } %&gt; 修改后的category-archive.ejs：&lt;% if (pagination &gt;= 2){ %&gt; &lt;!-- 置顶文章 --&gt; &lt;% page.posts.each(function(post, index){ %&gt; &lt;% if (post.top){ %&gt; &lt;%- partial('_widget/category-items', {index: index, post: post}) %&gt; &lt;% } %&gt; &lt;% }) %&gt; &lt;!-- 首页默认取最最新文章集 --&gt; &lt;% page.posts.sort('date', theme.homePageSortType).limit(theme.homeArticleShown).each(function(post, index){ %&gt; &lt;!-- 其余文章 --&gt; &lt;% if (!post.top){ %&gt; &lt;%- partial('_widget/category-items', {index: index, post: post}) %&gt; &lt;% } %&gt; &lt;% }) %&gt; &lt;% } else { %&gt; &lt;% page.posts.each(function(post, index){ %&gt; &lt;%- partial('_widget/category-items', {index: index, post: post}) %&gt; &lt;% }) %&gt; &lt;% } %&gt; 5. 重新部署hexo clean hexo g hexo d","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hemiaomiao.github.io/tags/hexo/"},{"name":"Sakura主题","slug":"Sakura主题","permalink":"https://hemiaomiao.github.io/tags/Sakura%E4%B8%BB%E9%A2%98/"}],"author":"Miaomiao"},{"title":"电脑壁纸","slug":"电脑壁纸","date":"2021-09-16T10:02:11.000Z","updated":"2022-03-12T08:23:27.455Z","comments":true,"path":"2021/09/16/电脑壁纸/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/16/%E7%94%B5%E8%84%91%E5%A3%81%E7%BA%B8/","excerpt":"","text":"![](https://cdn.jsdelivr.net/gh/hemiaomiao/cdn/blogImage/202203121612715.jpg) ![](https://cdn.jsdelivr.net/gh/hemiaomiao/cdn/blogImage/202203121612907.jpg) ![](https://cdn.jsdelivr.net/gh/hemiaomiao/cdn/blogImage/202203121612056.jpg) ![](https://cdn.jsdelivr.net/gh/hemiaomiao/cdn/blogImage/202203121612828.jpg) https://cdn.jsdelivr.net/gh/hemiaomiao/cdn/blogImage/202111281756463.jpg https://cdn.jsdelivr.net/gh/hemiaomiao/cdn/blogImage/202111281756362.jpg https://cdn.jsdelivr.net/gh/hemiaomiao/cdn/blogImage/202111281756857.jpg https://cdn.jsdelivr.net/gh/hemiaomiao/cdn/blogImage/202111281756322.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171643661.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202110261650860.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202110261650178.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171643016.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645677.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161804504.png https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171643209.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171643203.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644631.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645207.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645895.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644047.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645086.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645961.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645236.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645030.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645154.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645036.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645879.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645428.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645010.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645811.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645374.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645061.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645027.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644951.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171645972.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644301.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644266.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644091.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644265.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644734.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644271.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644367.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644337.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644239.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644396.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644092.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644434.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109171644176.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161915808.png https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161917661.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805481.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805278.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805773.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805923.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805284.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805421.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805136.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805603.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805187.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805224.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805972.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805523.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805207.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805866.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805753.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161805892.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806483.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806582.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806531.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806280.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806928.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806065.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806503.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806290.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806982.jpg https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806380.png https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806689.png https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806675.png https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806623.png https://cdn.jsdelivr.net/gh/HeMiaomiao/cdn/blogImage/202109161806068.png https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/startdash/bilibili.jpg https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/startdash/sakura.md.png https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/startdash/wangshiwu.jpg https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/music.jpg https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/about.jpg","categories":[{"name":"杂项","slug":"杂项","permalink":"https://hemiaomiao.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"壁纸","slug":"壁纸","permalink":"https://hemiaomiao.github.io/tags/%E5%A3%81%E7%BA%B8/"}],"author":"Miaomiao"},{"title":"clash for windows使用教程","slug":"clash-for-windows使用教程","date":"2021-09-16T08:45:34.000Z","updated":"2021-09-17T12:45:48.000Z","comments":true,"path":"2021/09/16/clash-for-windows使用教程/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/16/clash-for-windows%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"1. 下载安装 clash for windows选择合适自己机型的版本 clash for windows的下载地址 2. 设置节点的订阅链接方法1 方法2 3. 选择合适的节点节点一旁的数字代表延迟时间 4. 设置开机启动 设置节点的更新时间的步骤如下 注意: 每次关机的时候需要把clash for windows 退出 5. 下载安装SwitchyOmega插件SwitchyOmega插件的下载地址 下载成功之后，把SwitchyOmega插件的后缀.crx改成.zip，然后把zip文件解压 6. chrome浏览器加载已经解压的SwitchyOmega_Chromium插件会显示一个错误，不用管 7. 配置情景模式设置代理服务器和端口号 8. 配置自动切换设置需要代理网站的域名 9. 在浏览器上自由切换代理模式","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"Miaomiao"},{"title":"hexo Sakura主题美化教程","slug":"hexo-Sakura主题美化教程","date":"2021-09-13T08:27:02.000Z","updated":"2021-09-19T04:07:48.000Z","comments":true,"path":"2021/09/13/hexo-Sakura主题美化教程/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/13/hexo-Sakura%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/","excerpt":"","text":"站点配置文件 ———&gt; 博客的根目录/_config.yml主题配置文件 ———&gt; 博客的根目录/themes/next/_config.yml一. 设置文章的分类和标签博客的根目录\\themes\\Sakura\\languages\\zh-cn 二. 修改手机端的首页的底部博客的根目录\\themes\\Sakura\\layout_partial\\mheader.ejs 三. 修改每篇博客的底部博客的根目录\\themes\\Sakura\\layout_partial\\footer.ejs 四. 添加友链博客的根目录\\source\\links\\index 博客的根目录\\themes\\Sakura\\layout\\links.ejs 五. 关于的页面博客的根目录\\source\\about\\index 六. 设置hexo new “” 生成的博客的模板 在使用命令hexo new “博客名字”的时候，就是基于post.md脚手架来创建文章的markdown文件 博客的根目录\\scaffolds\\post 七. 使用搜索功能npm install hexo-generator-json-content --save 八. 图片背景1.博客的背景图片 博客的根目录\\themes\\Sakura_config.yml里面的bg属性 2.博客的头像 博客的根目录\\themes\\Sakura_config.yml里面的avatar属性 3.设置点击标签之后显示的背景图片 E:\\Blog\\themes\\Sakura\\languages\\zh-cn里面的 标签: img: 图片地址 4.点击标签之后显示的头像背景 博客文章里面的photos属性 5.博客封面图片 博客文章里面的photos属性 6.博客里面的头像图片 博客文章里面的avatar属性 7.博客里面的封面 博客文章里面的photos属性 九.设置代码高亮1.安装代码块高亮的插件，通过下面命令安装 npm i -S hexo-prism-plugin 2.修改博客根目录下的配置文件_config.yml, 关闭自带的高亮，在_config.yml里面看看有没有highlight，有的话用下面代码将其替换，没有的话自行添加，可以添加在代码的最末尾处 highlight: enable: false # 必须设置成false，否则和Sakura主题的代码区块显示冲突 line_number: false themes: paraiso-light auto_detect: true tab_replace: '' wrap: true hljs: true # 必须设置为true，否则浏览器打开代码不是高亮 prism_plugin: # 新增 prism 插件相关的配置 mode: 'preprocess' # realtime/preprocess theme: 'default' line_number: false # default false Sakura主题教程1 Sakura主题教程2 Sakura主题教程3 Sakura主题教程4 Sakura主题教程5 Sakura主题教程6","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hemiaomiao.github.io/tags/hexo/"},{"name":"Sakura主题","slug":"Sakura主题","permalink":"https://hemiaomiao.github.io/tags/Sakura%E4%B8%BB%E9%A2%98/"}],"author":"Miaomiao"},{"title":"hexo+github搭建个人博客的教程","slug":"hexo-github搭建个人博客的教程","date":"2021-09-13T08:22:38.000Z","updated":"2021-10-27T14:28:46.283Z","comments":true,"path":"2021/09/13/hexo-github搭建个人博客的教程/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/13/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%95%99%E7%A8%8B/","excerpt":"","text":"一．安装node.js （Node.js是Hexo插件运行的基础）node.js的下载地址：https://nodejs.org/zh-cn/download/releases/ 步骤： 选择适合电脑的相应的安装包 （选择后缀名是.msi的安装包） 下载完成之后直接安装，一直点“Next”即可 安装完整后，打开cmd命令（1）node -v 显示node.js的版本说明安装成功（2）npm -v 显示npm版本说明自带的npm安装成功 安装完的目录如下： 注意： 新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西 二．安装git通过git把Hexo生成的网页提交到Github pages上 git的下载地址 ： https://git-scm.com/download/win 下载完成之后直接安装，一直点“Next”即可 安装完整后，打开cmd命令，输入git version检查Git版本 三．安装Hexo1.在电脑常里创建一个文件夹，可以命名为Blog 2.点击进入创建的文件夹，点击鼠标右键选择“Git Bash Here” （1）安装Hexo （hexo默认会被安装到C盘） 输入以下命令： npm install hexo -g （2）检查是否安装成功 输入以下命令： hexo -v (3) 初始化该文件夹 输入以下命令： hexo init 初始化完成之后打开所在的文件夹可以看到以下文件： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 (4) 安装需要的组件 输入以下命令： npm install (5) 生成静态文件 输入以下命令： hexo g (6) 启动服务器 输入以下命令： hexo s 注意： 此时遇到一个情况，虽然hexo正常启动了，但是浏览器无法访问http://localhost:4000/，因为4000端口被占用了，输入hexo s -p 5000，然后访问http://localhost:5000/&nbsp; 四．gitHub创建个人仓库github的地址：https://github.com/ github创建个人仓库的步骤： 1.注册账号成功之后，点击右上角+号，选择New repository 2.进入一个页面，该页面的Repository name填写的格式必须是：用户名.github.io 3.必须勾选public和Add a README file 4.最后点击create repositorie按钮 五．生成SSH添加到gitHub点击进入之前创建的博客文件夹里面，选择Git Bash Here 1.依次输入以下命令： git config --global user.name \"你的GitHub用户名\" git config --global user.email \"你的GitHub注册邮箱\" cd ~/.ssh ls 注意： 第3个命令cd ~/.ssh和第4个命令ls就是检查是否已经存在 id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，那么就跳过步骤2，直接进入步骤3 2.输入命令 ssh-keygen -t rsa -C \"你的GitHub注册邮箱\" 接着回车三下 最后得到了两个文件：id_rsa和id_rsa.pub，默认存储路径是：C:\\Users\\Administrator\\ssh 3.在目录C:\\Users\\Administrator\\ssh找到id_rsa.pub文件,这个文件存储的是密钥 4.登录Github，点击 用户头像→Settings→SSH and GPG keys→New SSH key→将文件id_rsa.pub里面的内容复制到Key文本框中，&nbsp;title随便取，然后点击 Add SSH key 按钮 5.在电脑桌面右击，选择Git Bash Here，在git bash窗口中输入以下命令，验证是否添加成功 ssh -T git@github.com 六．将hexo部署到gitHub1.找到之前建的博客文件根目录，例如我的是在E:\\Blog，找到_config.yml配置文件2.打开_config.yml配置文件，翻到配置文件的最下方，修改为： deploy: type: git repo: git@github.com:HeMiaomiao/HeMiaomiao.github.io.git branch: main 注意： 现在分支不能写成master，因为github现在把默认分支从master改为了main 冒号后面有一个半角空格，并且type，repository，branch的首字母要对齐 3.点击进入之前创建的博客文件夹里面，右击选择Git Bash Here，依次输入以下命令： npm install hexo-deployer-git --save hexo clean hexo g hexo d 注意： 输入hexo d之后要输入gitHub账户的用户名和密码,命令行出现INFO Deploy done:git就表明发布成功 4.打开网页，输入http://GitHub账户的用户名.github.io，就可以看到个人博客啦! 七．更换Hexo主题1.地址：https://github.com/search?q=hexo-theme，找到自己喜欢的主题，点击进去查看文档里面的详细介绍，找到这样下载链接： 例如主题pacman: 主题next: 2.点击进入之前创建的博客文件夹里面，例如我的是在E:\\Blog，右击选择Git Bash Here，在窗口中输入上面找到的下载链接，例如下载主题pacman，就在窗口中输入git clone https://github.com/A-limon/pacman.git themes/pacman 3.点击进入之前创建的博客文件夹里面，找到配置文件_config.yml，把配置文件_config.yml里面的theme修改为现在选择的主题，格式为：theme: 主题名字，例如，theme:pacman 4.点击进入之前创建的博客文件夹里面，例如我的是在E:\\Blog，右击选择Git Bash Here，在窗口中依次输入以下命令： hexo clean hexo g hexo s hexo d 注意： 跟现在新选择的主题相关的配置在themes/主题名字/_config.yml里面,然后根据你的需要在这修改就行了 github + hexo搭建博客的教程1 github + hexo搭建博客的教程2 github + hexo搭建博客的教程3","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hemiaomiao.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://hemiaomiao.github.io/tags/github/"}],"author":"Miaomiao"},{"title":"jsDelivr+PicGo+github搭建个人图床","slug":"jsDelivr+PicGo+github搭建个人图床","date":"2021-09-12T12:18:44.000Z","updated":"2021-09-16T16:26:54.000Z","comments":true,"path":"2021/09/12/jsDelivr+PicGo+github搭建个人图床/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/12/jsDelivr+PicGo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"前言1.CDN加速CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 放在github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度。 2.jsDelivrjsDelivr是一个免费开源的CDN 解决方案，最大特点是支持github加速。jsDelivr和github结合起来就有了免费、快速的CDN,非常适合博客网站使用 步骤1： 在github新建一个仓库，用来存放博客图片 步骤2： 创建token令牌，并且复制保存该令牌 注意： token令牌只出现一次，所以要保存一下步骤3：下载PicGo下载地址：PicGo官网 注意： .exe为Windows系统版，.dmg为苹果系统版本 步骤4： 配置PicGo 注意：自定义域名的格式是： https://cdn.jsdelivr.net/gh/github用户名/仓库名 （这样就使用了jsDeliver进行DNS加速） 注意：把“PicGo设置”中的“时间戳重命名”打开，这样防止上传和github图床里面同名的图片的时候上传失败，比如图床已经有了3.png，现在如果不选择时间戳重命名，再上传一个名字是3.png的图片就会上传失败 通过PicGo上传图片成功之后，在github的仓库里面就会有该图片了","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hemiaomiao.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://hemiaomiao.github.io/tags/github/"}],"author":"Miaomiao"},{"title":"hexo发表博客的常用命令","slug":"hexo发表博客的常用命令","date":"2021-09-12T09:57:16.000Z","updated":"2021-09-17T03:01:48.000Z","comments":true,"path":"2021/09/12/hexo发表博客的常用命令/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/12/hexo%E5%8F%91%E8%A1%A8%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"注意： 以下命令需要在本地Blog根目录下执行 1. 新建博客 hexo new \"博客的名字\" 2. 清理hexo的缓存 （ 建议每次都进行clean操作 ）hexo clean 3. 生成静态文件根据已编辑的config或markdown生成html页面 hexo g 4. 启动本地服务器（可省略这一步）将生成的网页挂载在本地主机IP的4000端口上，用于预览主题，可以在正式发布前检验页面的内容和样 式是否正确无误，默认地址： http://localhost:4000/ hexo s 5. 部署到远程站点hexo d","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hemiaomiao.github.io/tags/hexo/"}],"author":"Miaomiao"},{"title":"解决cmd输入ping和ipconfig提示不是内部或外部命令","slug":"解决cmd输入ping和ipconfig提示不是内部或外部命令","date":"2021-09-11T09:43:18.000Z","updated":"2021-09-16T16:26:00.000Z","comments":true,"path":"2021/09/11/解决cmd输入ping和ipconfig提示不是内部或外部命令/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/11/%E8%A7%A3%E5%86%B3cmd%E8%BE%93%E5%85%A5ping%E5%92%8Cipconfig%E6%8F%90%E7%A4%BA%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"方法：1.右击计算机，选择“属性”，进入控制面板之后，点击“高级系统设置”，进入“系统属性”后，点击“环境变量”按钮 2.在系统变量里面找到“Path”变量，点击“编辑”按钮 3.在Path变量末尾添加“;c:\\windows\\system32”，点击”确定”保存","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hemiaomiao.github.io/tags/hexo/"}],"author":"Miaomiao"},{"title":"加速访问github的方法","slug":"加速访问github的方法","date":"2021-09-11T09:40:04.000Z","updated":"2021-09-16T16:26:10.000Z","comments":true,"path":"2021/09/11/加速访问github的方法/","link":"","permalink":"https://hemiaomiao.github.io/2021/09/11/%E5%8A%A0%E9%80%9F%E8%AE%BF%E9%97%AEgithub%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"1.打开IPAddress.com网站，查询下面3个网址对应的IP地址网站传送门 github.com assets-cdn.github.com github.global.ssl.fastly.net 比如，查询github.com的IP地址 注意： 查询第四个assets-cdn.github.com网址的时候会返回4个IP地址 在cmd里面分别ping4个IP地址，选择平均时间最短的那个IP地址 （格式：ping + 一个空格 + IP地址） 这样就得到了3个网站的IP地址： 140.82.114.3 github.com 185.199.111.153 assets-cdn.github.com 199.232.69.194 github.global.ssl.fastly.net 2.修改host文件host文件路径：C:\\Windows\\System32\\drivers\\etc 先右击以管理员身份打开host文件 把刚刚查到的3个需要重定向的网址和IP地址复制到host文件的最后面 格式： IP地址 + 空格 + 网址 140.82.114.3 github.com 185.199.111.153 assets-cdn.github.com 199.232.69.194 github.global.ssl.fastly.net 3.刷新 DNS打开cmd输入以下命令刷新DNS： ipconfig /flushdns","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"github","slug":"github","permalink":"https://hemiaomiao.github.io/tags/github/"}],"author":"Miaomiao"},{"title":"计算机复试之操作系统","slug":"计算机考研复试之操作系统","date":"2020-03-10T14:16:05.000Z","updated":"2021-09-16T16:24:12.000Z","comments":true,"path":"2020/03/10/计算机考研复试之操作系统/","link":"","permalink":"https://hemiaomiao.github.io/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"eg","slug":"eg","permalink":"https://hemiaomiao.github.io/tags/eg/"}],"author":"Miaomiao"},{"title":"计算机复试之数据结构","slug":"计算机考研复试之数据结构","date":"2020-03-10T14:16:04.000Z","updated":"2021-09-18T15:00:38.000Z","comments":true,"path":"2020/03/10/计算机考研复试之数据结构/","link":"","permalink":"https://hemiaomiao.github.io/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"1.算法的定义算法是对问题求解步骤的描述。 2.一个好的算法应该满足什么?一个好的算法应该满足：正确性、可读性、健壮性、效率和低存储量需求 正确性：算法能够正确的解决问题 可读性：算法应该具有良好的可读性，从而帮助人们理解 健壮性：输入非法数据时，算法能够适当地做出反应，而不会产生莫名其 妙的输出结果 效率和低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间 3.算法的5个特点有穷性、确定性、可行性、输入、输出 有穷性：一个算法必须在执行有穷步之后结束，每一步在有穷时间内完成 确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得到相同的输出 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现 输入：一个算法有零个或多个输入 输出：一个算法有一个或多个输出 4.算法效率的度量通过时间复杂度和空间复杂度来描述算法的效率 5.数据结构的定义数据结构是相互之间存在一种或多种特定关系的数据元素的集合 6.数据结构三要素逻辑结构、存储结构、数据的运算 （1）数据的逻辑结构 是指数据元素之间的逻辑关系。数据的逻辑结构包括线性结构和非线性结构。 线性结构：是指数据元素之间的关系是一对一的。线性结构包括线性表、栈、队列、串、数组 非线性结构：是指数据元素之间的关系是一对多或多对多的。非线性结构包括集合、树、图。其中集合：是指数据元素之间的关系是属于同一个集合树：是指数据元素之间的关系是一对多的图：是指数据元素之间的关系是多对多的 （2）数据的存储结构：是指数据结构在计算机中的表示。存储结构包括： 顺序存储：是指逻辑上相邻的元素存储的物理地址也相邻，顺序存储要求存储单元地址必须连续。顺序存储的优点是可以实现随机存取，缺点是可能产生外部碎片 链式存储：是指逻辑上相邻的元素存储的物理地址不一定相邻，链式存储结点之间的存储单元地址可以不连续。链式存储的优点是不会出现碎片，缺点是指针占用额外的存储空间，并且不能随机存取，只能顺序存取 索引存储：是存储信息的同时，还建立附加的索引表。优点是检索速度快，缺点是索引表额外占用空间，插入和删除慢 散列存储：是根据元素的关键字直接计算出元素的存储地址。优点是检索速度快，插入和删除快，缺点是可能出现元素的存储地址冲突，解决冲突需要额外的时间和空间开销 （3）数据的运算 7.常见的数据结构：数组、链表、栈、队列、树、图 8.时间复杂度是用算法中基本运算的频度f(n)来分析算法的时间复杂度，算法时间复杂度记为T(n)=O( f(n) ) 一个语句的频度：是指该语句在算法中被重复执行的次数 算法中的基本运算是最深层循环的语句 f(n)：算法中基本运算的频度 T(n)：算法中所有语句的频度之和 算法中基本运算的频度f(n)和算法中所有语句的频度之和T(n)是相同数量级 9. O是算法中所有语句的频度之和T(n)的数量级 10.算法的空间复杂度S(n)是算法所需要的存储空间 注： 算法的空间复杂度S(n)表示算法的问题规模是n 某算法的时间复杂度是O(n^2)，说明算法的执行时间和n^2成正比，问题规模是n 11.算法原地工作是指算法所需要的辅助空间是常量O(1) 12.递归就是函数里面自己调用自己。递归是把原问题分解成和原问题相似但是规模较小的若干个子问题，这些子问题可以用相同的解题思路来解决。递归的次数必须是有限的，递归需要定义一个临界条件作为递归的出口，当符合这个递归出口的时候递归结束。递归就是一种栈的应用，递归调用是入栈，输出结果是出栈。 13.递归和循环的比较 递归的优点：是代码简洁清晰，并且容易验证正确性递归的缺点：是递归调用次数过多容易造成栈溢出 循环的优点：是速度快，结构简单循环的缺点：是不能解决所有的问题，有的问题适合使用递归而不是循环 14.排序算法的稳定性是指待排序的元素里面有两个相同的元素，经过排序之后，两个元素的前后次序没有发生改变 15.内部排序是指在排序期间元素全部存放在内存中的排序 （1）冒泡排序（稳定）：时间复杂度为O(n^2),空间复杂度为O(1) 冒泡排序的算法思想：冒泡排序就是两两比较，如果是逆序就交换位置，直到所有记录都排好序。注：每一趟冒泡排序都会有一个元素到达正确的位置，所以n个元素冒泡排序要n-1趟 （2）直接插入排序（稳定）：时间复杂度为：O(n^2)，空间复杂度为O(1) 直接插入排序的算法思想：是把第一个元素作为已经排好序的子序列，每次把一个待排序的元素按值的大小插入到已排好序的子序列里面，直到所有的待排序元素都被插入到有序序列里面为止 直接插入排序的适用范围：顺序存储和链式存储的线性表 （3）归并排序（稳定）：时间复杂度为O(nlog2n),空间复杂度为O(n) 归并排序的算法思想：是把两个有序表组合成一个新的有序表。假设有n个元素，把 n 个元素看成 n 个长度为1的有序子表，然后子表两两归并，得到长度为 2 的有序子表，然后再把子表两两归并，一直重复这个操作，直到得到1个长度为n的有序表 （4）堆排序（不稳定）：时间复杂度为O(nlog2n),空间复杂度为O(1) *堆排序的算法思想：是首先把待排序的元素建立成初始堆，然后把初始堆调整成大根堆，然后把堆顶元素和堆底元素交换，交换之后堆底元素就是待排序元素里面的最大值，输出堆底元素，然后把剩下的元素重新调整成大根堆，然后再把堆顶元素和堆底元素交换，输出堆底元素，再把剩下的元素重新调整成大根堆，一直重复这个操作，直到堆里面只剩下一个元素 注: 大根堆：结点值 ≥ 左、右孩子结点的值 （从小到大排序） 小根堆：结点值 ≤ 左、右孩子结点的值 （从大到小排序） 调整成大根堆：每次从下往上，从右往左，看结点的值是不是大于等于左右孩子结点的值，如果不满足大根堆的定义，就把这个结点和左右孩子结点的最大值交换 调整成小根堆：每次从下往上，从右往左，看结点的值是不是小于等于左右孩子结点的值，如果不满足小根堆的定义，就把这个结点和左右孩子结点的最小值交换 （5）快速排序（不稳定）：时间复杂度为O(nlog2n),空间复杂度为O（log2n） 快速排序的算法思想：快速排序的基本思想是基于分冶法，选择待排序序列里面的第一个元素作为枢轴，所有比枢轴小的元素放左边，所有比枢轴大的放右边，形成左右两个子序列，对子序列进行一样的操作，直到所有的子序列里面都只有一个元素的时候停止 （6）简单选择排序（不稳定）：时间复杂度为O(n^2),空间复杂度为O(1) 简单选择排序的算法思想：是每一趟把待排序的元素里面值最小的元素和待排序的元素里面第一个元素交换位置，需要经过n-1趟排序 （7）折半插入排序（稳定）：时间复杂度为O(n^2),空间复杂度为O(1) 折半插入排序的算法思想：是把第一个元素作为已经排好序的子序列，每次把一个待排序的元素按值的大小插入到已排好序的子序列里面，直到所有的待排序元素都被插入到有序序列里面为止。折半插入排序和直接插入排序不同的地方是，折半插入排序是用折半查找的方法在有序子序列里面查找待排序的元素应该被插入的位置 折半插入排序的适用范围：顺序存储的线性表 （8）希尔排序（不稳定）：空间复杂度为O(1) 希尔排序的算法思想：是把待排序序列按相隔某个增量分割成若干个子序列，对各个子序列分别进行直接插入排序，逐渐缩小增量，重复上述步骤，直到序列基本有序，再对全体记录进行一次直接插入排序 希尔排序的适用范围：顺序存储的线性表 希尔排序的增量的选择：第一趟的增量是待排序元素个数的一半 n/2 ，第二趟的增量是第一趟增量的一半向下取整，一直到最后一趟增量是1 （9）基数排序（稳定）：时间复杂度为O(d(n+r)),空间复杂度为O(r)（ r是队列数量 ） 基数排序的算法思想：基数排序不需要比较和移动。基数排序是首先设置编号为0~9的十个桶，把待排序的元素先按照个位进行分配，然后收集，再按照十位进行分配，然后收集，然后按照百位进行分配，然后收集，依次类推，直到最后按照最高位进行分配，然后收集，整个排序结束 注: 快速排序是内部排序算法里面平均性能最好的排序算法 不稳定排序：堆排序、希尔排序、快速排序、简单选择排序 （口诀：堆希快简） 稳定排序：冒泡排序、直接插入排序、基数排序、归并排序、折半插入排序 （口诀：冒直基归折） 16.顺序查找： 顺序查找的思想：是把要查找的值依次和线性表中的元素进行比较。 顺序查找的优点是对数据的存储方式没有要求，顺序存储和链式存储都可以。顺序查找的缺点是效率低 17.二分查找（折半查找）：时间复杂度是O(log2n) 二分查找的思想：首先把要查找的值和中间位置mid处的元素进行比较，如果相等，说明查找成功，返回该元素的位置，如果要查找的值小于中间位置mid处的元素，就往mid的左边找，high=mid-1，重新计算mid的值，如果要查找的值大于中间位置mid处的元素，就往mid的右边找，low=mid+1，重新计算mid的值，然后再把要查找的值和中间位置mid处的元素进行比较，重复上面的操作，直到查找成功或者确定表里面没有要查找的元素，查找失败 二分查找的优点是比顺序查找的效率高，二分查找的缺点是只适用于有序的顺序表 18.分块查找是把查找表分成若干个子块，块与块之间是有序的，再建立一个索引表，索引表里面的每个元素含有各块的最大关键字和各块第一个元素的地址。第一步是确定待查找元素在索引表里面所在的块，第二步是在块内顺序查找 19.矩阵的压缩存储是针对像对称矩阵、三角矩阵、稀疏矩阵这样的特殊矩阵，矩阵里面的相同元素只存储一个，从而达到节省存储空间的目的 20.面向对象编程和面向过程编程的比较 面向过程就是分析出解决问题的步骤，然后用函数把这些步骤一步一步实现，使用的时候依次调用函数就可以了。 面向对象是把构成问题的事物抽象成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在解决问题的步骤里面的行为。就拿小明上学这件事情举例：面向过程：孩子起床→孩子洗漱→孩子出门→孩子去学校，面向对象：孩子{起床、洗漱、出门、去学校} 面向过程的性能比面向对象高，但是面向对象容易维护、容易复用、容易扩展。面向对象有封装、继承、多态的特征。 注: 1.对象：是描述客观事物的实体 2.类：具有相同属性和行为的对象的集合，类里面定义属性和行为。 封装：将类的某些信息隐藏在类的内部，只能通过该类提供的公共方法来对隐藏的信息进行操作和访问。一般是把属性限制为private私有，封装在一个类里面， 对每个私有属性提供public公共的setter和getter方法 继承：子类通过extends关键字可以继承父类的所有非私有属性和方法 多态：同一个行为具有多个不同的表现形式 重载：在同一个类里面方法的名称相同，但是参数类型或者参数个数不同 重写：子类继承父类的时候重写了父类的方法，在子类里面定义了和父类方法名称、参数类型、返回值类型一样的方法 21.线性表是由n个相同数据类型的数据元素构成的有限序列。线性表分为顺序表和链表。线性表除了第一个元素，每个元素都有一个直接前驱，除了最后一个元素，每个元素都有一个直接后继 22.顺序表和链表的比较顺序表：线性表的顺序存储 链表：线性表的链式存储 顺序表可以随机存取，链表只能顺序存取，不能随机存取 顺序表插入和删除需要移动大量的元素，链表插入和删除操作不需要移动元素，只需要修改指针 顺序表的存储单元地址必须连续，链表的存储单元地址可以不连续 顺序表的存储空间是一次性分配的，链表的存储空间是多次分配的，需要的时候申请就可以了 23.头指针和头结点的区别头指针是指向链表的第一个结点，头结点是放在第一个元素结点之前，头结点的数据域通常不存储信息。如果有头结点，那么头指针指向头结点，如果没有头结点，那么头指针指向第一个元素结点。 24.增加头结点的优点： 有了头结点，链表的第一个元素结点的插入和删除操作就和其它位置的结点一样了，不需要特殊处理 有了头结点，无论链表是不是为空链表，头指针都指向头结点，所以空表和非空表的处理得到了统一 25.循环单链表是链表中最后一个结点的指针域不是空，而是指向头结点 26.循环单链表的优点是可以从链表的任何一个结点开始遍历整个链表 27.双链表是链表的每个结点有两个指针域，分别指向前驱结点和后继结点 28.双链表的优点是可以方便地找到前驱结点 29.静态链表静态链表的指针表示的是下一个元素在数组中的位置 30.栈和队列的区别 栈和队列有相同的逻辑结构，都是线性结构，栈和队列都是操作受限的线性表 栈和队列都可以采用顺序存储和链式存储 栈是先进后出，在栈顶插入和删除元素，有栈顶指针top。队列是先进先出，在队尾插入元素，队头删除元素，有队头指针front和队尾指针rear 注: 队列插入元素是入队，删除元素是出队，所以队列在队尾入队，队头出队 队列删除元素（出队）修改队头指针front，插入元素（入队）修改队尾指针 rear 31.共享栈是利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，将两个栈的栈底设在共享空间的两端，两个栈顶向共享空间的中间延伸，这样能够更有效的利用存储空间 32.顺序队列 判断顺序队列队空：队头指针=队尾指针=0 顺序队列入队（插入元素）：队尾指针加1 顺序队列出队（删除元素）：队头指针加1 33.循环队列是把存储队列元素的表看成一个环，采用牺牲一个单元来区分队空和队满 注：% 是取余数 判断循环队列队空：队头指针 = 队尾指针 判断循环队列队满：队头指针 =（队尾指针 + 1）% 数组的容量 判断循环队列中的元素个数：(队尾指针-队头指针+数组的容量)%数组的容量 循环队列入队（插入元素）：队尾指针 =（队尾指针 + 1） % 数组的容量 循环队列出队（删除元素）：队头指针 =（队头指针 + 1） % 数组的容量 34.双端队列两端都可以进行入队和出队操作的队列 35.队列的应用层次遍历、缓冲区、页面替换算法 36.栈的应用括号匹配、递归、表达式求值 37.栈在括号匹配中的算法思想 出现左括号，都进栈； 出现右括号，和栈顶元素比较，如果括号匹配，就把栈顶元素出栈，如果括号不匹配，就返回不匹配信息直接结束程序 算法结束的时候，如果栈空，就说明括号匹配 38.栈在后缀表达式求值的算法思想顺序扫描表达式的每一项，如果该项是操作数，就入栈，若该项是操作符，则连续从栈中退出两个操作数Y和X，形成运算指令X操作符Y，并将计算结果重新压入栈中。当表达式的所有项都扫描并处理后，栈顶存放的就是最后的计算结果。 39.空串空串长度是0 40.空格串空格串长度是空格字符的个数 41.KMP算法思想从主串和模式串的第一个字符开始比较，当出现字符不匹配的时候，模式串向右移动的位数等于已匹配字符数-模式串对应的部分匹配 注: 部分匹配值是字符串的前缀和后缀的最长相等前后缀长度 42.散列函数一个把查找表中关键字映射成为该关键字对应的地址的函数 43.散列表（哈希hash表）根据关键字而直接进行访问的数据结构，散列表建立了关键字和存储地址之间的一种直接映射关系 44.散列函数（哈希hash函数）的构造方法 直接定址法：直接取关键字的某个线性函数值作为散列地址 除留余数法：取一个不大于但是最接近散列表表长的质数p，利用公式把关键字转换成散列地址（公式：H(key) = key % p ） 数字分析法：设关键字是r进制数，选取数码分布比较均匀的若干位作为散列地址 平方取中法：选择关键字的平方值的中间几位作为散列地址 45.解决哈希（hash）冲突的方法 线性探测法：是发生冲突的时候，顺序地查看表中下一个单元，直到找到一个空闲单元或者查遍全表。线性探测的缺点是可能会造成大量元素在相邻的散列地址上堆积，降低了查找效率 链地址法（拉链法）：是发生冲突的时候，把具有相同散列地址的关键字存放到同一个单链表里面 平方探测法：是发生冲突的时候，探测地址的增量序列是1^2、-1^2、2^2、-2^2，……k^2，-k^2，直到找到一个空闲单元或者查遍全表。平方探测法的优点是可以避免出现元素堆积，缺点是不能探测到散列表上的所有单元 再散列法：是发生冲突的时候，使用另外一个散列函数 伪随机序列法 注: 散列表查找成功的平均查找长度 = 所有关键字成功找到的比较次数之和 / 关键字个数 46.散列表的装填因子α是表示一个表的装满程度。 装填因子α = 关键字个数 / 散列表的长度 47.散列表的查找效率的取决因素散列函数、处理冲突的方法、装填因子 48.结点的度是该结点的孩子结点的个数 49.树的度是树里面结点的最大度数 50.树的存储结构双亲表示法、孩子表示法、孩子兄弟表示法 51.二叉树是指树里面的结点最多有两个孩子结点 52.满二叉树是指除了最后一层的叶子结点，其它层的每个结点都有两个孩子结点的二叉树 53.完全二叉树是指最后一层缺最右边的一些叶子结点，其它层的每个结点都有两个孩子结点的二叉树 54.二叉排序树 二叉树的定义：二叉排序树左子树的结点值 &lt; 根结点值 &lt; 右子树的结点值 二叉排序树的插入步骤：如果二叉排序树是空树，就把关键字当作根结点插入到空树里面，如果二叉排序树不是空树，如果关键字的值小于当前根结点的值，就把关键字插入到左子树，如果关键字的值大于当前根节点的值，就把关键字插入到右子树 55.线索二叉树是把二叉链表中的空指针改成指向前驱结点或者后继结点的线索 56.平衡二叉树是所有结点的左子树和右子树高度差的绝对值小于等于1的二叉树 57.平衡因子结点左子树和右子树的高度差 58.哈夫曼树是带权路径长度最小的二叉树 59.构造哈夫曼树的步骤把给定的权集里面的每个结点看成只有一个结点的二叉树，构成森林。每次从森林里面选择两棵根节点权值最小的二叉树构成新的二叉树，新的二叉树的根节点的权值是左、右子树的根节点的权值之和，从森林里面删除刚刚被选择的两棵二叉树，同时将新的二叉树加入到森林里面，重复上面的步骤，直到森林里面只剩下一棵树为止 60.哈夫曼编码统计每个字符出现的次数作为字符的权值，构造出哈夫曼树，从根节点出发，左分支是0，右分支是1 61.连通图是指无向图里面任意两个顶点之间都是连通的 62.图的存储结构邻接矩阵法、邻接表法、十字链表法、邻接多重表法 63.邻接矩阵与邻接表的比较邻接矩阵是用二维数组存储各顶点之间的邻接关系，邻接表是图中每个顶点建立一个单链表，单链表的结点是和该顶点有邻接关系的顶点。对于稀疏图，邻接表比邻接矩阵节省存储空间 64.深度优先搜索是首先访问图里面的一个起始顶点，然后访问和该起始顶点邻接但是没有被访问过的任意一个顶点，然后再访问和这个顶点邻接但是没有被访问过的任意一个顶点，重复上面的过程，直到一个顶点所有的邻接顶点都被访问过，然后依次退回到最近被访问的顶点，如果该顶点还有邻接顶点没有被访问过，就从这个顶点开始重复上面的过程，直到所有顶点都被访问过为止 65.广度优先搜索是首先访问图里面的一个起始顶点，然后访问和该起始顶点邻接但是没有被访问过的所有顶点，再按这些邻接顶点的先后次序依次访问和它邻接但是没有被访问过的所有顶点，重复这个过程，直到所有顶点都被访问过为止 66.最小生成树是包含图中所有的顶点，含有最少的边，并且不能有回路 67.普里姆Prim算法构造最小生成树（针对顶点）从图中任选一个顶点加入到集合里面，从和集合里面的顶点相连的边里面选择权值最小的边，把这条边的顶点加入到集合里面，重复上面的过程，直到所有的顶点都加入集合为止。 普里姆算法的时间复杂度是O(N^2) 68.克鲁斯卡尔Kruskal算法构造最小生成树（针对边）每次从没有被选择的边里面选择权值最小并且不构成回路的边，把这条边加入生成树里面，重复这个过程，直到所有的顶点都加入到生成树里面为止。 克鲁斯卡尔算法的时间复杂度是O（ElogE） E：是边数 注: 克鲁斯卡尔Kruskal算法适合边少但是顶点多的图 69.最短路径是指从一个顶点到图中任意一个顶点的路径所经过的边的权值之和最小的路径 70.迪杰斯特拉Dijkstra算法求最短路径 迪杰斯特拉算法是求单源最短路径。 迪杰斯特拉的算法思想： 首先把起始顶点加入到集合里面，更新起始顶点到其它各个顶点的距离，找到距离最小的路径，然后把这个路径的顶点加入到集合里面，然后把这个顶点作为中心，看起始顶点到其它各个顶点的距离是不是比原来小，如果小的话就更新，然后找到距离最小的路径，把这个路径的顶点加入到集合里面，重复上面的步骤，直到所有的顶点都加入到集合里面。 迪杰斯特拉算法要求边的权值不能是负值，时间复杂度是O(n^2) 71.弗洛伊德Floyd算法是求最短路径 弗洛伊德Floyd算法是求任意顶点之间的最短路径 弗洛伊德Floyd算法里面边的权值可以是负值，时间复杂度是O(n^3) 72.拓扑排序是从AOV网中选择一个没有前驱的顶点，输出该顶点，然后删除该顶点和以该顶点为起点的所有边，重复上面的过程，直到当前的AOV网为空或者当前AOV网不存在没有前驱的顶点为止 73.关键路径是AOE网里面从源点到汇点的路径长度最大的路径 74.AOV网与AOE网的区别AOV网的顶点表示活动，有向边表示活动之间的前后关系，AOV网的边没有权值。AOE网的顶点表示事件，有向边表示活动，边上的权值表示完成活动的开销。AOV网和AOE网都是有向无环图，但是它们的边和顶点代表的意思不一样。 75.贪心算法、动态规划、分治法的比较 贪心算法：是每次都选择当前状态下最好的选择，也就是局部的最优解，而不考虑这个局部最优解对全局的影响。贪心算法是自顶向下的方式进行，例如迪杰斯特拉Dijkstra算法采用了贪心算法 动态规划：是把原问题分解成若干个有重叠的子问题，保存已经解决的子问题的结果防止后面重复计算。动态规划算法是自底向上的方式进行。动态规划分为背包问题（01背包、完全背包、多重背包）、区间dp 分治法：是把原问题分解成若干个独立的子问题，递归地解决这些子问题，然后再合并子问题的解从而得到原问题的解。例如归并排序 76.程序设计语言的发展历史，每一类的特点 机器语言：是计算机能够直接识别的二进制代码的集合。机器语言难学难写 汇编语言：是把符号语言的指令转换为机器指令。汇编语言不能通用 面向过程：是分析出解决问题的步骤，然后用函数把这些步骤实现，使用的时候依次调用函数就可以了 面向对象：是把客观存在的事物抽象成对象，用对象去描述事物的行为。 注: 面向过程的性能比面向对象高，但是面向对象容易维护、容易复用。 面向对象有封装、继承、多态的特征 77.函数调用传参的方式有值传递和地址传递 值传递：是把变量、常量、数组元素作为函数参数，形参值的变化不会影响到实参 地址传递：是把数组名或者指针作为函数参数，形参值的变化就是实参的变化 78.函数调用的返回方法用return返回函数的值，返回值的类型根据函数类型决定，如果没有返回值，函数就要定义成void类型 79.有哪些控制结构有顺序结构、选择结构（if、switch）、循环结构（while型循环、util型循环） 80.一维数组和顺序表的异同顺序表和数组都可以随机存取，插入和和删除都要移动大量的元素，顺序表的位序从1开始，数组下标从0开始 81.带头结点的单链表删除数据为x的元素定义两个指针变量，一个指针变量pre指向头结点，一个指针变量p指向第一个元素结点，指针一个指针变量指向头结点，另一个指针变量指向第一个元素结点，开始，依次比较每个结点的值，如果等于数据x，就把这个结点的 82.顺序表、单链表怎么插入元素 顺序表插入元素：在第i个位置插入元素，首先判断i是不是合法，如果i合法，把第i个元素和第i个元素后面的所有元素右移一个位置，然后把元素插入到第i个空位置 单链表插入元素：先检查插入位置的合法性，然后找到待插入位置的前驱结点，然后让新结点就指向了这个前驱结点的后继结点，前驱结点指向新结点 83.顺序结构怎么存储二叉树是用一组连续的存储单元从上往下、从左往右存储二叉树的结点。 注: 链式存储是结点里面有数据域，左指针域，右指针域 84.怎么找前K个最大元素先把元素用快速排序进行排序，然后取出前K个元素，时间复杂度是O（NlogN) 85.如何判断哈希函数的优劣哈希函数计算出来的存储地址应该能等概率、均匀地分布在整个地址空间里面，从而减少冲突的发生，哈希函数应该尽量简单，能够在较短时间内计算出关键字的存储地址 86.KMP算法和朴素算法的比较 朴素算法：从主串和模式串的第一个字符开始比较，当出现字符不匹配的时候，把模式串向右移动一位然后从头开始比较。时间复杂度O（m*n） KMP算法思想：从主串和模式串的第一个字符开始比较，当出现字符不匹配的时候，模式串向右移动的位数等于已匹配字符数-模式串对应的部分匹配值。时间复杂度是O（m+n） 注: 部分匹配值：是前缀和后缀的最长相等长度 87.n！怎么算第一种方法是用循环求阶乘，设循环变量i为从 1 变化到 n，变量sum的初始值定义为1，循环里面让循环变量i和 sum 相乘，把结果赋给 sum 第二种方法是用递归求阶乘，递归出口是n等于1的时候直接返回1，结束递归 88.阶乘较大数据溢出怎么处理用数组来保存阶乘的结果，每个位置存放1个数字，数组的第一个位置存放个位，第二个位置存放十位，依次类推 89.二维矩阵相乘需要几层循环需要三层循环，第一层循环控制左边矩阵的行，第二层循环控制右边矩阵的列，第三层循环控制左边矩阵的列，也是右边矩阵的行，比如说前2层循环确定了是左边矩阵第一行和右边矩阵第一列，那么第三层循环就是让左边第一行第一列的元素和右边第一行第一列元素相乘，然后加上左边第一行第二列的元素和右边第二行第一列的元素相乘，依次类推","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"考研复试","slug":"考研复试","permalink":"https://hemiaomiao.github.io/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hemiaomiao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Miaomiao"},{"title":"计算机复试之数据库","slug":"计算机考研复试之数据库","date":"2020-03-10T14:16:03.000Z","updated":"2021-09-18T15:06:58.000Z","comments":true,"path":"2020/03/10/计算机考研复试之数据库/","link":"","permalink":"https://hemiaomiao.github.io/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"1.数据(Data)是数据库中存储的基本对象 2.数据库DB（Database）是长期储存在计算机内、有组织的、可共享的大量数据的集合 3.数据库（DB）的基本特征 数据按一定的数据模型组织、描述和储存 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 4.数据库（DB）的作用 实现数据共享、减少数据的冗余 保证数据一致性和可维护性 实现数据的集中控制、故障恢复 实现数据的独立性 5.数据库管理系统DBMS（Database Management System）是位于用户和操作系统之间的一层存储和管理数据库的软件，是数据库系统的核心 6.数据库管理系统(DBMS)的作用科学地组织和存储数据、高效地获取和维护数据 7.数据库管理系统(DBMS)的功能 数据定义功能 数据组织、存储和管理功能 数据操纵功能 数据库的事务管理和运行管理功能 8.数据库系统DBS（Database System）在计算机系统中引入数据库后的系统构成。数据库系统是由数据库、数据库管理系统、应用系统、数据库管理员组成 9.数据库系统(DBS)的构成 数据库（DB） 数据库管理系统（DBMS） 应用系统 数据库管理员（DBA） 10.数据管理对数据进行分类、组织、编码、存储、检索和维护 11.数据库系统（DBS）的特点 数据结构化 数据的共享性高，冗余度低，易扩充 数据独立性高 数据由数据库管理系统（DBMS）统一管理和控制 12.数据共享的好处 减少数据冗余，节约存储空间 使系统易于扩充 13.数据库管理系统（DBMS）提供的数据控制功能 数据的安全性保护 数据的完整性检查 并发控制 数据库恢复 14.数据库管理员DBA（Database Administrator）对数据库进行规划、设计、协调、维护和管理等工作的人员 15.数据库管理员（DBA）的职责 决定数据库中的信息内容 决定数据库的存储结构 定义数据的安全性要求和完整性约束条件 16.数据独立性应用程序与数据库中数据的物理存储和数据的逻辑结构之间是相互独立的，数据独立性是由数据库管理系统的二级映像功能来保证的 物理独立性: 指应用程序和数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不受影响 逻辑独立性: 指应用程序和数据库中数据的逻辑结构是相互独立的。当数据的逻辑结构改变了，应用程序不受影响 17.现实世界中客观对象的抽象过程现实世界中的客观对象抽象为概念模型，再把概念模型转换为逻辑模型，最后把逻辑模型转化为物理模型 18.数据模型（Data model）是描述数据的一组概念和定义 19.数据模型的分类 概念模型：是按用户的观点来对数据建模 逻辑模型：是按计算机系统的观点对数据建模 物理模型：描述数据在系统内部的表示方式，在磁盘上的存储方式 20.常用的数据模型 层次数据模型 网状数据模型 关系数据模型 面向对象模型 对象关系模型 21.数据模型的组成要素 数据结构 数据操作 完整性约束条件 22.实体（Entity）实体是客观存在并可以相互区别的事物 23.属性（Attribute）实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画 24.码（Key）码是唯一标识实体的属性集 25.实体之间的联系一对一（1:1）、一对多（1：n）、多对多（n：m） 26.E-R图有三个组成部分实体、属性、联系 实体：用矩形表示，矩形框内写实体名 属性：用椭圆表示，并用无向边将其与相应的实体连接起来 联系：用菱形表示，菱形框内写联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来 27.层次数据模型因为现实世界中很多事物之间本身就存在层次关系，所以用树形结构来表示实体和实体间的联系，层次数据模型只能直接处理一对多的实体联系 28.网状数据模型网状模型能处理多对多的实体联系 29.关系数据模型关系数据模型中将实体和实体之间的联系全部用表来表示，关系数据模型中数据的逻辑结构是一张表，一个关系就是一张表，它由行和列组成，关系数据模型中的一行是一个元组，一列是一个属性 30.关系数据模型的数据结构 关系：实体和实体之间的各种联系都是用关系来表示，一个关系对应一张二维表，表的每行对应一个元组，表的每列对应一个域。表示格式：关系名（属性1，属性2，…，属性n） 元组：表中的一行就是一个元组 属性：表中的一列就是一个属性 主码：表中的某个属性组，它可以唯一确定一个元组 域：是一组具有相同数据类型的值的集合，是属性的取值范围 分量：元组中的一个属性值 关系模式：对关系的描述。表示格式：关系名（所有属性名，属性来自的域，属性和域的映射，属性间的依赖关系） 关系必须是规范化的，最基本的规范条件是：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表 31.关系模式和关系的区别关系是关系模式在某一时刻的状态，关系是不断变化的，关系模式是对关系的描述，是稳定的 32.关系数据模型的完整性约束条件 / 数据库的完整性 实体完整性：主键不能为空，主键必须唯一，不能重复 参照完整性：外键为空或者外键等于被参照关系（被参照表）中的主键值（实体完整性和参照完整性是关系的两个不变性） 用户定义的完整性：是针对数据库中数据的约束条件,给属性值约定范围 33.关系数据模型的优点 实体和各类联系都用关系来表示 具有更高的数据独立性，更好的安全保密性 简化了程序员的工作和数据库开发建立的工作 34.模式是数据库逻辑结构和特征的描述，模式是相对稳定的 35.实例是模式的一个具体值，实例是不断变化的 36.数据库系统的三级模式结构 模式（又叫逻辑模式）： 是数据库中所有数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个模式，模式是数据库系统的模式结构的中间层。 外模式（又叫用户模式）：是数据库用户使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图。模式和外模式是一对多的关系，一个外模式可以被多个应用程序所使用，一个应用程序只能使用一个外模式。 内模式（又叫存储模式）： 是数据物理结构和存储方式的描述，一个数据库只有一个内模式 37.数据库的二级映像功能 外模式／模式映像 : 对于每一个外模式，有一个外模式／模式映像，保证了数据的逻辑独立性。当模式改变时，数据库管理员对外模式／模式映像作相应改变，使外模式保持不变。 模式／内模式映像 : 模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。数据库中模式／内模式映像是唯一的，保证了数据的物理独立性。当数据库的存储结构改变了，数据库管理员对模式／内模式映像作相应改变，使模式保持不变。 38.关系数据库 定义： 是所有实体和实体之间联系的关系的集合 关系数据库的优点: 是使用方便，易于维护，降低了数据冗余和数据不一致的概率，支持SQL和事务 关系数据库的缺点: 是读写性能比较差 40.关系代数的5种基本操作 （每个元组就是一行，每个属性就是一列） 选择σ：从一个表中把满足条件的元组找出来 投影π：选择出若干属性列组成新的关系，投影要去掉重复元组（行） 笛卡尔积：笛卡尔积就是把两个关系的元组进行拼接，包含了两个关系的所有元组的各种可能的组合。比如现在有两个关系，关系R有2个元组，关系S有3个元组，笛卡尔积就是拿关系R的第一个元组去跟关系S的三个元组分别进行拼接，再拿关系R的第二个元组去跟关系S的三个元组分别进行拼接，一共得到6个元组 差：元组属于关系R但不属于关系S 并：元组来自关系R或者关系S，并起来的关系不允许有重复行 41.关系代数的其它操作 交：元组既属于关系R又属于关系S 连接：是从两个关系的笛卡尔乘积中选择满足一定条件的元组。如果没有条件限制，连接就是笛卡尔乘积 注: 等值连接 equal join：是从两个关系的笛卡尔乘积中选择属性值相等的元组（两个表中列值相等的）。格式如下：select *from 表1，表2where 表1.列名 = 表2.列名 自然连接 natural join：自然连接是一种特殊的等值连接，自然连接是从两个关系的笛卡尔乘积中选择相同的属性里面属性值相等的元组（两个表中相同的列里面值相等的），并且要去掉结果中的重复列 内连接inner join：内连接包括等值连接和不等值连接。格式如下：select *from 表1inner join 表2on 表1.列名 = 表2.列名 外连接 ：外连接包括左连接和右连接 左连接（左外连接）left join：两个关系作自然连接，但是左边关系中的所有元组保留下来，右边关系中不符合条件要舍弃的元组填空值 右连接（右外连接）right join：两个关系作自然连接，但是把右边关系中的所有元组保留下来，左边关系中不符合条件要舍弃的元组填空值 42.SQL的功能（1）数据操纵：插入insert、删除delete、更新update 插入数据： insert into 表名（属性1，属性2，......） values(属性1的值，属性1的值，......); 删除数据： delete from 表名 where + 条件 更新数据： update 表名 set属性 = 修改的值 where + 条件 （2）数据查询 select [distinct] 所查询的内容 （distinct是去掉重复行） from 表名 where + 条件 group by 列名 having 条件 order by 列名 asc（升序）/desc（降序） 43.基本表基本表是实际存在的表，基本表的数据存储在数据库中，在SQL中一个关系就对应一个基本表 44.虚表虚表的数据不是存储在数据库中，虚表在数据库里面只存储定义 45.视图是由基本表构成的虚表，数据库里面只存储视图的定义，不存储视图对应的数据，视图对应的数据存放在基本表中。所以基本表里面的数据发生变化，从视图中查询的数据也随之改变 46.视图的作用 视图能够简化用户的操作 视图使用户能以多种角度看待同一数据 视图对重构数据库提供了一定程度的逻辑独立性 视图能够对机密数据提供安全保护 适当的利用视图可以更清晰的表达查询 47.码包括候选码和主码 48.候选码（候选键）如果关系中的某个属性组合的值能唯一地标识一个元组，那么这个属性组合就是候选键。换句话说，当一个属性组合能够推出关系中所有的属性，但是这个属性组合的任何一个真子集不能推出所有的属性，则这个属性组合是候选键。候选键不是唯一的 49.主码（主键）从候选键中选择一个作为主键。主键是唯一的，不能重复，并且主键不能为空 50.外码（外键）这个属性不是自身关系的主键，而是另一个关系的主键，则这个属性是外键 51.主属性包含在候选键里面的属性就是主属性 52.非主属性不包含在候选键里面的属性就是非主属性，去掉主属性剩下的属性都是非主属性 53.函数依赖在属性X能推出属性Y，那么就说Y函数依赖于X，写作X → Y 54.完全函数依赖属性X能推出属性Y，但是属性X的任何一个真子集不能推出属性Y，那么就说Y对X是完全函数依赖 55.部分函数依赖属性X能推出属性Y，属性X的真子集能推出属性Y，那么就说Y对X是部分函数依赖 56.传递函数依赖属性X能推出属性Y，属性Y能推出属性Z，那么就说Z对X是传递函数依赖 57.引入的范式的原因 数据冗余 更新异常 插入异常 删除异常 58.范式是我们在设计数据库结构过程中所要遵循的规则和指导方法 59.第一范式(1NF)关系模式的每一个属性都是不可再分的，换句话说就是二维表的每一列都是不可再分的，不允许表中套表 60.第二范式(2NF)关系模式首先要满足第一范式，并且不存在非主属性对候选键的部分函数依赖 例1. 候选键AB可以推出非主属性C，主属性A可以推出非主属性C，则非主属性C对候选键AB是部分函数依赖 例2. 候选键AB可以推出非主属性C，主属性A推不出来非主属性C或者主属性B推不出来非主属性C，则非主属性C对候选键AB是完全函数依赖 61.第三范式(3NF)关系模式首先要满足第二范式，并且不存在非主属性对候选键的传递函数依赖 例如：候选键AB可以推出非主属性D，非主属性D可以推出非主属性C，则非主属性C对候选键AB是传递函数依赖 62.BC范式(BCNF)关系模式首先要满足第三范式，并且不存在主属性对候选键的传递函数依赖和部分函数依赖 63.判断范式的步骤 第一步：求闭包，就是对左边属性进行一个组合，使得左边属性组合能够推出所有属性 第二步：找出候选键，左边属性组合就是候选键 第三步：找出主属性和非主属性，包含在候选键里面的属性就是主属性，不包含在候选键里面的属性就是非主属性 第四步：根据范式定义去判断 64.索引是对数据库的表里面一列或多列的值进行排序的一种结构。索引的优点是提高查询速度，索引的缺点是索引会占用物理存储空间，并且索引需要动态维护。 65.索引的类型 B+树索引（优点是动态平衡） hash索引（优点是查找速度快） 聚集索引：物理存储顺序与逻辑顺序相同 非聚集索引 唯一索引 66.游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果 67.存储过程是由PL/SQL语句写的过程，经过编译和优化后存储在数据库服务器中。存储过程使用时只要调用就可以了，运行效率高。 68.触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程，当用户对表进行insert插入、delete删除、update更新的操作时，服务器会自动激活相应的触发器，触发器可以用来防止对数据的不正确修改。 69.触发器的类型 行级触发器 语句级触发器 70.触发器的工作原理触发器触发的时候，系统会自动在内存中创建deleted表或者inserted表，deleted表和inserted表只允许读，在触发器执行完成后，会自动删除，inserted表临时保存了插入或者更新后的记录行，deleted表临时保存了删除或者更新前的记录行。 注: 更新隐含的操作：删掉原来的再插入新的，原来的放在deleted表，插入的新的放在inserted表 71.事务是用户定义的一个数据库操作序列，这些操作要么全部做，要么全部不做，事务是一个不可分割的工作单位，事务是恢复和并发控制的基本单位。事务通常以begin transaction开始，以commit或者rollback结束。 注: commit表示提交事务的所有操作，具体来说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中，事务正常结束 rollback表示回滚，就是说在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已经完成的更新操作全部撤销，回滚到事务开始时的状态 72.事务的特性事务有四个特性，简称为ACID特性，分别是： 原子性：事务是数据库的逻辑工作单位，事务中包括的操作要么都做，要么都不做。 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性状态是指数据库中只包含成功事务提交的结果。 隔离性：一个事务的执行不能被其他事务干扰，也就是说一个事务内部的操作和使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰 永久性：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，接下来的其他操作或故障不应该对其执行结果有任何影响。 73.事务并发执行的目的 改善系统的资源利用率和吞吐率 改善短事务的响应时间 74.需要对事务并发执行进行并发控制的原因为了保证事务的一致性和隔离性 75.如果没有并发控制对事务的并发操作进行正确的调度，可能会产生如下问题并发一致性问题： 丢失修改：是两个事务对同一数据并发的写入所引起的 读脏数据：是一个事务读取另一个事务修改了但没有提交的数据所引起的 不可重复读：是一个事务读取数据之后，另一个事务修改了数据，如果此时第一个事务再次读取数据，两次读取的结果可能不一样 76.数据库的隔离级别 未提交读：一个事务可以看到其他未提交的事务的数据 提交读：一个事务只能读取已经提交的事务的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的 可重复读：保证同一个事务多次读取同一数据的结果是一样的 可串行化：强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。这种隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行。 77.数据库中的死锁事务1等待事务2释放锁，事务2等待事务1释放锁，事务之间出现了循环等待的情况，如果不进行干预，会一直等待下去形成死锁 78.数据库中死锁的预防 一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行 顺序封锁法：预先对数据规定一个封锁顺序，所有事务都按这个顺序实行封锁 79.数据库中死锁的检测 超时法：如果一个事务的等待时间超过了规定的时间就认为发生了死锁 等待图法：如果有向图出现了回路，说明发生了死锁 80.封锁是事务在对某个数据操作之前，先向系统发出请求，对数据加锁，加锁后事务对该数据有了一定的控制，在事务释放数据上的锁之前，其他的事务不能更新此数据，封锁是实现并发控制的一个非常重要的技术。 81.封锁的类型 排它锁（又称为写锁）：是只允许当前事务读取和修改数据，在当前事务释放数据上的排它锁之前，其他事务不能再读取和修改数据 共享锁（又称为读锁）：是当前事务只能读取数据但不能修改数据，其他事务也可以读取数据，但是在当前事务释放数据上的共享锁之前，其他事务不能修改数据 82.封锁协议对数据加锁需要约定一些规则，例如何时申请封锁，何时释放封锁 83.两段封锁协议是指每个事务必须分为两个阶段，第一个阶段是加锁，第二个阶段是解锁 84.数据库的完整性数据库的完整性是指数据的正确性和相容性，数据库的完整性是为了防止数据库中存在不正确的数据。数据库的完整性的防范对象是不正确的数据，防止他们进入数据库。 85.数据库的安全性是保护数据库防止恶意的破坏和非法的存取。数据库的安全性的防范对象是非法用户和非法操作，防止他们对数据库数据的非法存取。 86.varchar(n)和char(n)的区别varchar存储的字符串长度是可变的，最大长度为n，char存储的字符串长度是固定的n 87.drop和delete的区别drop是直接删除这张表，delete是删除表中的数据，并且可以通过commit提交或者rollback回滚 88.关系模式和关系的区别关系是关系模式在某一时刻的状态，关系是不断变化的，关系模式是对关系的描述，是稳定的 89.数据冗余同一信息在数据库中存储了多个副本 90.恢复中最经常使用的技术（建立冗余数据最常用的技术） 数据库转储 登记日志文件 91.恢复的基本原理系统发生故障的时候，利用数据库中的后备副本和日志文件，以及数据库镜像中的冗余数据来重建数据库。 92.JDBC是java程序连接数据库服务器的应用程序接口 93.常见的数据库MySQL&nbsp;、SQL Server、Oracle 94.数据字典是各类数据描述的集合，数据字典包括数据项、数据结构、数据流、数据存储、处理过程 95.数据项不可再分的数据单位 96.数据库设计的步骤需求分析、概念设计、逻辑设计、物理设计、数据库实施、数据库运行和维护 97.常见的数据库的约束 非空约束（NULL/NOT NULL） 唯一约束（UNIQUE） 主键约束（PRIMARY KEY） 外键约束（FOREIGN KEY） 检查约束（CHECK） 98.数据管理技术的发展过程 人工管理阶段 文件系统阶段 数据库系统阶段 99.SQL关系数据库的标准语言 100.SQL特点 综合统一 高度非过程化 面向集合的操作方式 以同一种语法结构提供多种使用方式 语言简洁，易学易用 101.DDL数据库定义语言 102.DQL数据库查询语言 103.DML数据库操纵语言 104.DCL数据控制语言，用于控制用户对数据的访问权限 105.关系语言的分类 关系代数语言 关系演算语言 SQL语言 106.数据库安全性控制的常用办法 用户身份鉴别 存取控制 视图机制 审计 数据加密 107.ODBC的优点 移植性好 能同时访问不同的数据库 108.ODBC的工作流程 配置数据源 初始化环境 建立连接 分配语句句柄 执行SQL语句 结果集处理 中止处理 109.数据库系统的故障的种类 事务内部的故障 系统故障 介质故障 计算机病毒 110.E-R图转换成关系模型的原则 E-R图的实体转换为关系（表名） E-R图的属性转换为关系的属性 E-R图的联系转换成关系模型要根据联系的类型一对一、一对多、多对多分别讨论 111.数据库的级联数据库的级联是用来设计一对多的关系。比如级联更新的时候，如果一个主键值被改了，那么和它关联的外键也需要修改","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"考研复试","slug":"考研复试","permalink":"https://hemiaomiao.github.io/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/"},{"name":"数据库","slug":"数据库","permalink":"https://hemiaomiao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"Miaomiao"},{"title":"计算机复试之英语面试","slug":"计算机考研复试之英语面试","date":"2020-03-10T14:16:02.000Z","updated":"2021-09-16T16:24:38.000Z","comments":true,"path":"2020/03/10/计算机考研复试之英语面试/","link":"","permalink":"https://hemiaomiao.github.io/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95%E4%B9%8B%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95/","excerpt":"","text":"一. 英语自我介绍的思路：第一段：名字 + 年龄 + 籍贯 + 专业第二段：奖学金+比赛获奖情况第三段：性格 + 考研原因 + 选择这个学校的原因 + 录取之后的承诺 二. 中文自我介绍： 我的名字是XX，XX，我来自XX省XX市。2019年我从大学毕业，我的专业是软件工程。 在大学期间，我大部分时间都在学习上。我已经通过了大学英语4级。我获得了三等奖学金和国家励志奖学金。除此之外，我参加了我们系的ACM算法团队。我参加了蓝桥杯比赛，并获得了省级一等奖和国家三等奖。当然，这些荣誉也是仅代表过去，更宝贵的是大学四年的经历。 我认为我是一个努力的学生。我对编程有浓厚的兴趣，因此我想获得进一步地教育。中国民航大学的浓厚学术氛围吸引了我。如果我能被这所大学录取，我将尽力提高自己的专业水平和实践能力。 三. 英文自我介绍： Good morning/afternoon,deer professors. It is my honor to take this interview. My name is XX,XX years old. I come from XX, XX Province.I graduated from university in 2019.My major was software engineering.&nbsp; During my college life,I spend most of my time on study.I have passed College English Test level 4.I obtained the third-class scholarship and the National Encouragement Scholarship.In addition, I took part in the ACM algorithm team of our department.I participated in the LanQiao Cup Competition ,and won the provincial first prize and national third prize.Of course, these honors only represent the past, more precious is the experiences of the four years in college. I think that I am a hard-working student.I have a strong interest in programming,so I want to get further education.大学名字 attracts me with the strong academic atmosphere.&nbsp;If I can be admitted to this university, I will try my best to improve my professional level and practical ability. That’s all. Thank you. 四. 英文问题：​( 1 ) 个人问题 1. 为什么选择XX大学 ( choose to study at our school / institute ) Firstly,this university has good teachers and I want to be guided by them.Secondly,I am deeply attracted by the strong academic atmosphere in this university.I think that I will be able to broaden my horizon and deepen my knowledge in this university. 首先，这所大学有好的老师，我想被他们指导。第二，我是深深的被这所学校的浓厚的学术氛围吸引。我认为我将能够在这所大学拓宽我的视野，加深我的知识。 2. 为什么要考研 / 为什么辞职考研 ( take the postgraduate examination / go back to study instead of going on with your work / graduate school ) Firstly,I have a strong interest in computer.I hope that I can make some progress in the academic fields.Secondly,I want to engage in the work related to frontier fields in the future, but the courses during my undergraduate study are not enough to support me to find a job in these fields. So I choose to take the postgraduate examination. 第一，我对计算机有浓厚的兴趣。我希望我能在学术领域能有所进步。第二，我想在未来从事前沿技术相关的工作，但是本科期间的课程不足以支撑我在这个领域找到工作。所以我选择参加研究生考试。 resignation [ˌrezɪɡˈneɪʃn]&nbsp; 辞职 resign [rɪˈzaɪn]&nbsp; 辞职 3. 读了研究生后的计划 ( plan in the postgraduate study ) Firstly,I will try my best to study professional knowledge.Secondly,I will participate in the research project of the teacher.Under the guidance of the teacher,I will choose certain research direction.Thirdly,I will read the paper actively and cherish every practical opportunity.Finally,I will continue to strengthen my English level. 第一，我会努力学习专业知识。第二，我会参加老师的研究项目。在老师的指导下，我会选择确定的研究方向。第三，我会积极阅读论文并珍惜每一次的实践机会。最后，我将继续提高我的英语水平。 4. 如何平衡学习和课余生活 I developed a good habit of making plans.I will stick the plan on the computer desktop.When I finish a small goal,I will give myself a certain reward.Since then,my study and life have become more organized. 我养成了制定计划的好习惯。我将粘贴计划在计算机桌面上。当我完成一个小目标时，我会给自己一定的奖励。从那时起，我的学习和生活变得更加井井有条。 5. 有什么兴趣爱好（hobby / interest）I like reading books, because the plot of many books are very attractive, after reading it can cause me to think about something.I recently read love you as love life.The author of this book is Wang Xiaobo.I am moved by their spirit of keeping romantic and having their own unique ideas during difficult times. 我喜欢读书，因为许多书的情节都很吸引人，读完它会使我思考一些事情。我最近读过《爱你就像爱生命》，这本书的作者是王小波，我被他们在困难时期保持浪漫并拥有自己独特的想法的精神而打动。 novel [ˈnɑːvl] 小说 6. 介绍一下你的家人 There are four people in my family:father,mother,sister and I.My family is very democratic.My demands and interests will be fully respected by parents.I think my curiosity has a lot to do with my family atmosphere. 在我的家庭有四个人：爸爸，妈妈，妹妹和我。我的家庭是非常民主的。我的要求和兴趣会得到父母的充分尊重。我认为我的好奇心和我的家庭氛围有很大关系 democratic [ˌdeməˈkrætɪk]&nbsp; 民主的 7. 英语的重要性 English is very important for postgraduate students.Because students need to read English paper. 英语对于研究生非常重要。因为学生需要阅读英语论文。 8. 为什么选择这个专业 I am very interested in my major.During my college life,I actively participated in many competitions and got satisfactory results.If I want to make some achievement in my major,I need to continue to carry out in-depth study.This is the reason why I continue to apply for this major. 我对我的专业很感兴趣，在我大学期间，我积极地参加了很多比赛并且取得了令人满意的结果。如果我想在我的专业上取得一些成就，我需要继续进行深入的学习。这就是我继续申请这个专业的原因。 9. 介绍一下你的大学生活（college’s life）I feel that my college life is very colorful.During my college life,I spend most of my time on study.I took part in the ACM algorithm team of our department.I participated in some competitions and got satisfactory results. In addition, I made many friends. 我感觉自己的大学生活是丰富多彩的。在大学期间，我大部分时间都花在学习上。我参加了我系的ACM算法团队。我参加了一些比赛并取得了令人满意的结果。除此之外，我交了很多朋友 10. 介绍一下你的家乡（hometown） I come from LuAn,Anhui Province.My hometown has beautiful landscape and delicious food.The most famous specialty of LuAn is tea.The people here are straightforward and full of passion.I am no exception.Because of my character,I made many friends in university. 我来自安徽六安。我的家乡有美丽的风景和美味的食物。六安最著名的特产是茶叶。这里的人们直率的并且充满热情。我也不例外。由于我的好的性格，我在大学里结了很多朋友。 11. 介绍一下自己的大学 My university is in HeFei.My alma mater is not a famous school,but I appreciate it because it gives me a chance to improve myself.Four years’ study had made me an independent,optimistic people.I really appreciate the education my university gave me. 我的大学在合肥。我的母校不是著名的学校，但是我感激它，因为它给了我一个机会去提高我自己。四年的学习使我成为一个独立，乐观的人。 我非常感谢大学给我的教育。 12. 本科最喜欢的课程（favorite subject） My favorite course is software engineering.Because this course introduce many engineering ideas, which help me form a systematic cognition of software engineering. 我最喜欢的课程是软件工程，因为这门课会介绍很多工程的思想，它帮助我形成了对软件工程的系统认识。 form 形成 systematic [ˌsɪstəˈmætɪk] 系统的 cognition 认识 13. 最喜欢的一本书(favorite book) My favorite book is lox ve you as love life.The author of this book is Wang Xiaobo.I am moved by their spirit of keeping romantic and having their own unique ideas during difficult times. 我最喜欢的一本书是《爱你就像爱生命》，这本书的作者是王小波，我为他们保持浪漫并在困难时期拥有自己独特的想法而感动。 14. 最喜欢的音乐(favorite music) My favorite music is songs of Li Jian. It’s very warm and inspiring. 我最喜欢的音乐是李健的歌曲。它是非常温暖和鼓舞人心的 15. 你的优点是什么(&nbsp;greatest strength/advantage) My advantage is perseverance. Once I decide to get to do some thing, no matter how hard it seems to be, I always make sure that I stick to the end. 我的优点是毅力。一旦我决定做一些事情，无论它看起来多困难，我总是确保坚持到最后 16. 你的缺点是什么( weakness / disadvantage / shortcoming / defect ) Sometimes I have a hard time saying no to others.But I am also happy that I can help others.Therefore,I don’t think it is a complete weakness that I don’t know how to refuse others.As long as it is within my ability, I will try my best to help others. 有时候我不太会拒绝别人。但是我也是开心的我能够帮助其他人。所以我并不认为不知道怎样去拒绝别人是完全的缺点。只要在我的能力范围内，我会尽力去帮助其他人。 17. 为什么来天津上学 I like Tianjin very much. This is a modern city with convenient transportation. And it is very close to Beijing, the capital of our country. 我非常喜欢天津。这是一座现代化的城市，交通很方便，并且距离我国首都北京很近。 18. 你做什么工作 My job is software development / software testing. 我的工作是软件开发 / 软件测试 19. 有没有联系导师 I don’t contact a supervisor.Because my friend told me that I didn’t need to contact tutors before the interview. 我没有联系导师。因为我的朋友告诉我，在面试前我不需要联系导师。 20. 如果没有被录取，会做什么（&nbsp;If you failed this time what will you do） If I couldn’t pass the test,it means that I have some shortcoming in professional knowledge.I will reflect on my problem and try to find the solutions,which is the biggest harvest of this experience. 如果我失败了，那意味着我在专业知识上是有一些缺点，我将反思我的问题并且尝试找到解决方案，这才是这次经历的最大的收货。 harvest [ˈhɑːrvɪst]&nbsp; 收获 21. 某门课不及格的原因 （ fail in this course ) This course is really difficult for me.I spend a lof of time reviewing it.I didn’t expect that I would fail the examination.Later,I passed the make-up examination successfully. 这门课程对我来说确实有一定的难度，我花了很多时间去复习，没想到最后的结果还是不及格。后来，我顺利通过了补考。 22. 怎么管控自己的业余时间/主要时间( control spare time / main time ) When I was in college, I usually work in the lab or study in the library. When I have a break, I read some books. 在大学的时候，我通常在实验室忙项目或者在图书馆学习，休息的时候读书 23.介绍一下最喜欢的老师(favorite teacher) My favorite teacher is the teacher of software engineering.Because she is very humorous and kind. 我最喜欢的老师是软件工程老师，因为她很幽默和善良。 24.介绍一下自己的性格（personality / character) I am a positive and optimistic person. I think that any difficulty can be overcome.Once I decide to get to do some thing, no matter how hard it seems to be, I always make sure that I stick to the end. 我是一个积极并且乐观的人。 我认为任何困难都可以克服。一旦我决定去做某件事，无论看起来有多困难，我都会确保我坚持到底。 25.本科获奖情况（prize / honors and awards ) During my college life,I obtained the third-class scholarship and the National Encouragement Scholarship.In addition, I participated in the LanQiao Cup Competition ,and won the provincial first prize and national third prize. 在大学期间，我获得了三等奖学金和国家励志奖学金。除此之外，我参加了蓝桥杯比赛，并获得了省级一等奖和国家三等奖。 ( 2 ) 学术问题 1. 什么是深度学习（ deep learning ） Deep learning is the biggest breakthrough in the field of artificial intelligence.&nbsp;It is a complete subversion of the traditional computing model, bringing great opportunity for change. 深度学习是人工智能领域的最大突破。它是对传统计算模型的完全颠覆，带来了巨大的变革机会。 subversion [səbˈvɜːrʒn] 颠覆 2. 什么是数据挖掘 （ data mining ） Data mining refers to the process of searching for information hidden in a large amount of data through algorithms. 数据挖掘是指从大量的数据中通过算法搜索隐藏于其中信息的过程。 mining [ˈmaɪnɪŋ] 挖掘 3. 什么是计算机视觉 Computer vision deals with how computers can be made for gaining high-level understanding from digital images or videos.&nbsp;It seeks to automate task that the human visual system can do.&nbsp; 计算机视觉解决了如何制造计算机以从数字图像或视频获得高级理解的问题。它寻求使人类视觉系统可以完成的任务自动化。 visual 视觉的 computer vision 计算机视觉 4. 什么是大数据 (Your understanding of the research direction） The big data is to find useful information from the mass of data. 大数据就是从海量数据中寻找出有用的信息 5. 什么是人工智能 Artificial intelligence refers to the technology of presenting human intelligence through ordinary computer programs. The research scope of artificial intelligence covers many aspects. At present, the most widely used one is machine learning. 人工智能是指通过普通的计算机程序来呈现人类智能的技术。人工智能的研究范围涉及很多方面。目前，最广泛使用的是机器学习。 artificial intelligence 人工智能 machine learning 机器学习 6. 什么是软件工程 Software engineering is to implement software system in an organized and planned way according to engineering. By applying software engineering to software development, the development efficiency and cost can be improved, as well as improve the software quality. 软件工程就是根据工程的需要，有组织、有计划地实施软件系统。通过将软件工程应用于软件开发，可以提高开发效率和成本，提高软件质量。 7. 什么是ACM ACM is an algorithm competition. ACM是算法竞赛。 8. ACM对你的影响 It cultivated my self-learning ability and team spirit.In addition,because the algorithm question was written in English, so it improved my English reading ability. 它培养了我的自学能力和团队合作精神。另外，因为算法问题是用英语写的，因此提高了我的英语阅读能力。 遇到暂时想不出，需要思考的问题：Could you please give me some time to think about this question? 遇到没听清楚的问题：Sorry, I didn’t hear it clearly, could you please speak it again? 遇到不会的问题：Sorry, I don’t know how to answer this question. 回答完问题之后：This is my answer. 遇到暂时想不出，需要思考的问题：Could you please give me some time to think about this question? 遇到没听清楚的问题：Sorry, I didn’t hear it clearly, could you please speak it again? 遇到不会的问题：Sorry, I don’t know how to answer this question. 回答完问题之后：This is my answer.","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"考研复试","slug":"考研复试","permalink":"https://hemiaomiao.github.io/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/"}],"author":"Miaomiao"},{"title":"计算机考研复试的准备","slug":"计算机考研复试的准备","date":"2020-03-10T14:16:01.000Z","updated":"2021-09-16T16:23:52.000Z","comments":true,"path":"2020/03/10/计算机考研复试的准备/","link":"","permalink":"https://hemiaomiao.github.io/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95%E7%9A%84%E5%87%86%E5%A4%87/","excerpt":"","text":"复试注意事项​复试准备： 不要染头发、一张草稿纸和笔。 ​如果网上复试的话，一定要保证网络和收音设备没问题，提前测试好。如果中途网络出现问题，直接凉凉。 复试三个部分​英语自我介绍及口语部分、专业课知识考查、综合能力考核。 第一部分：英语面试​ 先进行英文自我介绍，（有的学校可能会有中文自我介绍）。可以去b站看一些up主的介绍，然后改一下。最好找英语专业的同学帮忙看一下细节错误。一定要背的滚瓜烂熟。（我复试太紧张，就背错行了，但是也要硬着头继续背下去，千万不要卡壳） 介绍完成后，会有一位老师考察英语口语部分。题目大概都是些常见的对话，比如：你为什么选我们学校？你想研究什么方向？你的家乡来自哪里？ （这些题目应该都有人整理，可以自己去买）。如果没听清，可以说Parton？让老师重复一遍。如果真的不会，可以只说几个单词。（去年老师问我想学什么研究方向，我就只说了Machine Learning这个单词。宁愿少说，不要犯错）。 第二部分：专业课知识​根据你们复试课考核要求，复习书上的知识点。由于考察是口述，但是会有计算，所以需要先准备好一张草稿纸和笔。 ​ 涉及到计算的知识点一定要练熟，因为复试的时候会很紧张，很难算出来或者算对。 如果是定义的介绍部分，最好多读几遍，保证复试的时候不会卡壳（定义可以不完全按照书上一字不拉的讲），比如我去年的有道题目考“数据库事务的特征”。我先说了分为ACID特征，然后A的全称是什么，具体是什么功能。 第三部分：综合能力考核​主要聊一些大学经历和项目经历。考察学生的科研能力和学术能力 ​复试之前学校会收集每个学生的获奖证明等。奖学金，竞赛都可以，越多越好。 代码能力考核：会问你大学期间做过哪些项目，参加过哪些算法相关的比赛。如果没有获奖也没关系，可以说参加过一些算法培训，有过相关经验。 获奖经历：主要是奖学金，四六级，数学竞赛（有些老师比较看重数学能力）。 科研能力：英语基础比较好，阅读英文文献不费力。自主学习能力强，课余时间学过某些编程语言和一些技术。 毕业设计：如果自己毕设中用了某些算法模型，最好花时间大致搞懂一下。尤其是模型中的参数是多少，参数值为什么要那么设置等。老师不会问代码是增删改查怎么写的，毕竟是研究生复试不是公司面试。 不要讲一些没用的经历，比如参加过什么志愿者，组织了什么娱乐社团活动。老师看中的是科研能力。 总结​前两阶段，书上基础知识要复习扎实。综合部分尽可能表现优秀，但是不懂的东西不要乱说（老师肯定比你懂得多）。主要考察科研能力和个人能力。能显示出科研能力的项目、比赛说的越多越好，先从最重要的说。 ​","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"考研复试","slug":"考研复试","permalink":"https://hemiaomiao.github.io/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/"}],"author":"Miaomiao"},{"title":"MarkDown语法","slug":"MarkDown语法","date":"2020-01-13T14:16:01.000Z","updated":"2021-10-28T11:30:19.189Z","comments":true,"path":"2020/01/13/MarkDown语法/","link":"","permalink":"https://hemiaomiao.github.io/2020/01/13/MarkDown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1.写代码的格式：3个` ( ``` ) 代码内容 3个` ( ``` ) 效果如下： hello world 2.标题## 二级标题 ### 三级标题 效果如下： 二级标题三级标题3.字体**文字加粗** *文字倾斜* ***文字倾斜加粗*** ~~文字加删除线~~ `字体粉红色标出` 效果如下： 文字加粗文字倾斜文字倾斜加粗文字加删除线字体粉红色标出 4.设置字体的大小、颜色、字体风格&lt;font color=red size=3.5&gt;**注意**&lt;/font&gt; 效果如下： 注意 注： 字体颜色的种类 5.给文字加链接[文字内容](链接地址) 效果如下：我的博客 6.插入图片![](图片的链接地址) 效果如下： 7.列表（1）无序列表 * 列表内容 （中间用一个空格隔开） 效果如下： 列表内容 （2）有序列表 1. 列表内容 （中间用一个空格隔开） 效果如下： 列表内容 8.换行时缩进两字符&amp;emsp;文字内容 效果如下： 换行时缩进两字符 9.表格表头|表头|表头 :-|:-:|-: 内容|内容|内容 内容|内容|内容 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二 10.文字内容引用&gt; 引用的内容 (中间有一个空格) 效果如下： 奥利给","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"markDown","slug":"markDown","permalink":"https://hemiaomiao.github.io/tags/markDown/"}],"author":"Miaomiao"},{"title":"Java面试题总结","slug":"Java面试题总结","date":"2020-01-13T14:16:01.000Z","updated":"2021-09-16T16:29:30.000Z","comments":true,"path":"2020/01/13/Java面试题总结/","link":"","permalink":"https://hemiaomiao.github.io/2020/01/13/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"一.Java基础1. 面向过程和面向对象的区别面向过程的性能比面向对象高，但是面向对象容易维护、容易复用、容易扩展 2. Java的数据类型(1) 基本数据类型 ： 直接赋值就可以① 整型 （byte、short、long、int）② 字符型 （char）③ 浮点型 （float、double）④ 布尔型 （boolean） (2) 引用数据类型 ： 通过关键字new创建对象，然后把这个对象赋给相应的变量String类型是引用数据类型，它比较特殊，可以通过关键字new来创建对象，也可以通过字符串直接赋值。比如：String s = new String(“abc”);String s = “abc”; 3. equals和==的区别 ==用于基本数据类型的变量，比较的是变量的值是否相等 ==用于引用数据类型的变量，比较的是变量所指向的对象的堆内存地址是否相同 equals方法只能比较引用数据类型的变量，不能用于比较基本数据类型的变量。 equals方法如果没有重写，比较的是变量所指向的对象的堆内存地址是否相同 equals方法如果重写了，要看是如何重写的，像String类内部重写了equals方法，比较的是变量所指向的对象的内容是否相同 注：引用数据类型的变量也称为对象的引用 4. Java的内存机制5. 面向对象的特征 封装 :(1) 概念 : 将类的某些信息隐藏在类的内部，只能通过该类提供的公共方法来对隐藏的信息进行操作和访问(2) 实现步骤 : 一般是把属性限制为private私有，封装在一个类里面， 对每个私有属性提供public公共的setter和getter方法例如： public class Person{ private String name; private int age; ​ public int getAge(){ return age; } ​ public String getName(){ return name; } ​ public void setAge(int age){ this.age = age; } ​ public void setName(String name){ this.name = name; } } /* F文件名 : RunEncap.java */ public class RunEncap{ public static void main(String args[]){ EncapTest encap = new EncapTest(); encap.setName(\"James\"); encap.setAge(20); encap.setIdNum(\"12343ms\"); System.out.print(\"Name : \" + encap.getName()+ \" Age : \"+ encap.getAge()); } } 以上代码编译运行结果如下: Name : James Age : 20 public方法是外部类访问该类成员变量的入口任何要访问类中私有成员变量的类都要通过这些getter和setter方法 继承 : 子类通过extends关键字可以继承父类的所有非私有属性和方法 多态 :(1) 概念 ： 同一个行为具有多个不同表现形式(2) 多态存在的三个必要条件 ：① 继承② 重写 ： 子类对父类中某些方法进行重新定义③ 向上转型 ： 父类引用变量指向子类对象，Parent p = new Child();(3) 多态的定义格式 :父类类型 变量名 = new 子类类型();(4) 多态的调用过程 ：当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。","categories":[{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hemiaomiao.github.io/tags/Java/"}],"author":"Miaomiao"}],"categories":[{"name":"科研","slug":"科研","permalink":"https://hemiaomiao.github.io/categories/%E7%A7%91%E7%A0%94/"},{"name":"技术","slug":"技术","permalink":"https://hemiaomiao.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"杂项","slug":"杂项","permalink":"https://hemiaomiao.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://hemiaomiao.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"KPI异常检测","slug":"KPI异常检测","permalink":"https://hemiaomiao.github.io/tags/KPI%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"},{"name":"tag1","slug":"tag1","permalink":"https://hemiaomiao.github.io/tags/tag1/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hemiaomiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Matplotilib","slug":"Matplotilib","permalink":"https://hemiaomiao.github.io/tags/Matplotilib/"},{"name":"Pandas","slug":"Pandas","permalink":"https://hemiaomiao.github.io/tags/Pandas/"},{"name":"Python","slug":"Python","permalink":"https://hemiaomiao.github.io/tags/Python/"},{"name":"numpy","slug":"numpy","permalink":"https://hemiaomiao.github.io/tags/numpy/"},{"name":"智能运维","slug":"智能运维","permalink":"https://hemiaomiao.github.io/tags/%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4/"},{"name":"Linux","slug":"Linux","permalink":"https://hemiaomiao.github.io/tags/Linux/"},{"name":"算法","slug":"算法","permalink":"https://hemiaomiao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"markDown","slug":"markDown","permalink":"https://hemiaomiao.github.io/tags/markDown/"},{"name":"机载网络","slug":"机载网络","permalink":"https://hemiaomiao.github.io/tags/%E6%9C%BA%E8%BD%BD%E7%BD%91%E7%BB%9C/"},{"name":"机器学习","slug":"机器学习","permalink":"https://hemiaomiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"英语六级","slug":"英语六级","permalink":"https://hemiaomiao.github.io/tags/%E8%8B%B1%E8%AF%AD%E5%85%AD%E7%BA%A7/"},{"name":"隐语义模型","slug":"隐语义模型","permalink":"https://hemiaomiao.github.io/tags/%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B/"},{"name":"推荐系统","slug":"推荐系统","permalink":"https://hemiaomiao.github.io/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"},{"name":"hexo","slug":"hexo","permalink":"https://hemiaomiao.github.io/tags/hexo/"},{"name":"Sakura主题","slug":"Sakura主题","permalink":"https://hemiaomiao.github.io/tags/Sakura%E4%B8%BB%E9%A2%98/"},{"name":"壁纸","slug":"壁纸","permalink":"https://hemiaomiao.github.io/tags/%E5%A3%81%E7%BA%B8/"},{"name":"github","slug":"github","permalink":"https://hemiaomiao.github.io/tags/github/"},{"name":"eg","slug":"eg","permalink":"https://hemiaomiao.github.io/tags/eg/"},{"name":"考研复试","slug":"考研复试","permalink":"https://hemiaomiao.github.io/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hemiaomiao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"数据库","permalink":"https://hemiaomiao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java","slug":"Java","permalink":"https://hemiaomiao.github.io/tags/Java/"}]}